<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>combtest.runner &mdash; py-combtest 1.0.0.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="py-combtest 1.0.0.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for combtest.runner</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a set of tools for running Walks. This includes running</span>
<span class="sd">Walks in stages using e.g. SyncPoints, and ways to run Walks in parallel across</span>
<span class="sd">a cluster.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="kn">from</span> <span class="nn">combtest.action</span> <span class="kn">import</span> <span class="n">SyncPoint</span>
<span class="kn">import</span> <span class="nn">combtest.bootstrap</span> <span class="kn">as</span> <span class="nn">bootstrap</span>
<span class="kn">import</span> <span class="nn">combtest.central_logger</span> <span class="kn">as</span> <span class="nn">central_logger</span>
<span class="kn">from</span> <span class="nn">combtest.central_logger</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">import</span> <span class="nn">combtest.config</span> <span class="kn">as</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">combtest.encode</span> <span class="kn">as</span> <span class="nn">encode</span>
<span class="kn">import</span> <span class="nn">combtest.utils</span> <span class="kn">as</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">combtest.walk</span> <span class="kn">as</span> <span class="nn">walk</span>
<span class="kn">from</span> <span class="nn">combtest.walk</span> <span class="kn">import</span> <span class="n">CancelWalk</span><span class="p">,</span> <span class="n">WalkFailedError</span><span class="p">,</span> \
                          <span class="n">WalkOpTracer</span>
<span class="kn">import</span> <span class="nn">combtest.worker</span> <span class="kn">as</span> <span class="nn">worker</span>



<span class="c1"># NOTE: A WalkRunner is associated 1-to-1 with a worker_id</span>
<div class="viewcode-block" id="WalkRunner"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner">[docs]</a><span class="k">class</span> <span class="nc">WalkRunner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A WalkRunner simply wraps a ``Walks`` execution method with some tracking</span>
<span class="sd">    for reporting stats. The user is free to inherit and add more stats as they</span>
<span class="sd">    see fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resp_object</span><span class="p">,</span> <span class="n">reporting_interval</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="s1">&#39;error_count&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="s1">&#39;cancel_count&#39;</span><span class="p">:</span> <span class="mi">0</span>
                     <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reporting_interval</span> <span class="o">=</span> <span class="n">reporting_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>

        <span class="c1"># This class doesn&#39;t use this, but it could be used by a descendent if</span>
        <span class="c1"># desired. Here for child classes to use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="n">resp_object</span>

<div class="viewcode-block" id="WalkRunner.count_total"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner.count_total">[docs]</a>    <span class="k">def</span> <span class="nf">count_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to count the number of ``Walks``/Walk segments we started</span>
<span class="sd">        running.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporting_interval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Started running </span><span class="si">%d</span><span class="s2"> walks&quot;</span> <span class="o">%</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="WalkRunner.count_error"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner.count_error">[docs]</a>    <span class="k">def</span> <span class="nf">count_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called on a ``Walk`` execution error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;error_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="WalkRunner.count_cancel"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner.count_cancel">[docs]</a>    <span class="k">def</span> <span class="nf">count_cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when a ``Walk`` is canceled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cancel_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">error_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;error_count&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cancel_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cancel_count&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="WalkRunner.run_walk"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner.run_walk">[docs]</a>    <span class="k">def</span> <span class="nf">run_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_to_run</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to run an individual ``Walk``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_total</span><span class="p">()</span>
        <span class="n">canceled</span> <span class="o">=</span> <span class="n">walk_to_run</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">canceled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CancelWalk</span><span class="p">()</span></div>

<div class="viewcode-block" id="WalkRunner.prep_work_call"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkRunner.prep_work_call">[docs]</a>    <span class="k">def</span> <span class="nf">prep_work_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_to_run</span><span class="p">,</span> <span class="n">walk_ctx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to wrap a ``Walk`` into a callable that accepts a single</span>
<span class="sd">        argument: the ``ctx``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_walk</span><span class="p">(</span><span class="n">walk_to_run</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">walk_ctx</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CancelWalk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_cancel</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_error</span><span class="p">()</span>
                <span class="n">central_logger</span><span class="o">.</span><span class="n">log_remote_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">return</span> <span class="n">run</span></div></div>


<span class="k">class</span> <span class="nc">WalkThreadPool</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">ThreadPool</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">on_error_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_item</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>


<div class="viewcode-block" id="WalkExecutorService"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkExecutorService">[docs]</a><span class="k">class</span> <span class="nc">WalkExecutorService</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">CoordinatorService</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplest rpyc-based services for running walks across the cluster: the user</span>
<span class="sd">    only needs to provide a list of ``Walks`` to their corresponding ServiceGroup.</span>
<span class="sd">    The rest is handled.</span>

<span class="sd">    Note:</span>
<span class="sd">        The user should probably not be calling into this directly. They</span>
<span class="sd">        should be starting it up via rpyc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: PORT/WRAP</span>
    <span class="c1">#: Override the type of ``WalkRunner`` used, here or in a child class</span>
    <span class="n">WALK_RUNNER_TYPE</span> <span class="o">=</span> <span class="n">WalkRunner</span>
    <span class="c1">#: Override the type of ``ThreadPool`` used for executing ``Walks``, here</span>
    <span class="c1">#: or in a child class</span>
    <span class="n">WORKER_TYPE</span> <span class="o">=</span> <span class="n">WalkThreadPool</span>

    <span class="k">def</span> <span class="nf">on_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WalkExecutorService</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">on_connect</span><span class="p">()</span>

        <span class="c1"># Maps worker_id-&gt;WalkRunner instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_service_port</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_service_port</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next_walk_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_walk_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rlock</span><span class="p">:</span>
            <span class="n">id_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_walk_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_walk_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">id_out</span>

<div class="viewcode-block" id="WalkExecutorService.work_repack"><a class="viewcode-back" href="../../api.html#combtest.runner.WalkExecutorService.work_repack">[docs]</a>    <span class="k">def</span> <span class="nf">work_repack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is called back to repackage each work item sent to the service.</span>
<span class="sd">        The call is an opportunity to e.g. do some deserialization, wrap the</span>
<span class="sd">        ``Walk`` in a ``WalkRunner``, or anything else the user needs to prep</span>
<span class="sd">        the work for execution.</span>

<span class="sd">        :param object work: the work to execute; typically this will be e.g. a</span>
<span class="sd">                            JSONified ``Walk``.</span>
<span class="sd">        :param object ctx: a ``ctx`` copied in for executing the ``Walk``</span>
<span class="sd">        :param dict resp: a dict to which response objects can be attached by</span>
<span class="sd">                          the ``Walk`` for retrieval later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;runner&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ctx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;resps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">runner_kwargs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;runner_kwargs&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">WALK_RUNNER_TYPE</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="o">**</span><span class="n">runner_kwargs</span><span class="p">)</span>

            <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;walk_ctxs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">runner</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span>
        <span class="n">current_walk</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>

        <span class="n">walk_ctx</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;walk_ctxs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walk_ctx</span><span class="p">)</span>

        <span class="n">walk_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_walk_id</span><span class="p">()</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">prep_work_call</span><span class="p">(</span><span class="n">current_walk</span><span class="p">,</span> <span class="n">walk_ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">call</span></div>

    <span class="k">def</span> <span class="nf">exposed_start_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">worker_id</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">WalkExecutorService</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">exposed_start_work</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
                                                                        <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                                                                        <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span>
                                                                       <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctxs</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;runner&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">worker_id</span>

    <span class="k">def</span> <span class="nf">exposed_start_workers_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">worker_id</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">WalkExecutorService</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">exposed_start_workers_on</span><span class="p">(</span>
                <span class="n">work</span><span class="p">,</span>
                <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctxs</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;runner&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">worker_id</span>

    <span class="k">def</span> <span class="nf">exposed_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">worker_id</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">WalkExecutorService</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">exposed_run</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
                                                                 <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                                                                 <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span>
                                                                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctxs</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;runner&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">worker_id</span>

    <span class="k">def</span> <span class="nf">exposed_start_remote_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                     <span class="n">log_namespace</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            ip, port - where we connect our logging socket handler</span>
<span class="sd">            log_dir - where we output our logs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_ip</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_my_IP</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">central_logger</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">central_logger</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>


                <span class="k">if</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">log_fname</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.log&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">my_ip</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_service_port</span><span class="p">,</span>
                                                  <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
                    <span class="k">if</span> <span class="n">log_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">log_fname</span> <span class="o">=</span> <span class="n">log_namespace</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">log_fname</span>
                    <span class="n">verbose_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">log_fname</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span> <span class="o">=</span> <span class="n">verbose_file_path</span>
                    <span class="n">central_logger</span><span class="o">.</span><span class="n">add_file_handler</span><span class="p">(</span><span class="n">verbose_file_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log_namespace</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">log_namespace</span> <span class="o">=</span> <span class="n">log_dir</span>
            <span class="n">log_namespace</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.log&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">my_ip</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_service_port</span><span class="p">,</span>
                                               <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>

            <span class="n">central_logger</span><span class="o">.</span><span class="n">add_op_trace</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span>
                                        <span class="n">WalkOpTracer</span><span class="p">,</span>
                                        <span class="n">log_namespace</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">op_trace</span><span class="o">.</span><span class="n">fname</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">add_socket_handler</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exposed_gather_resp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resps</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>

        <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;error_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;cancel_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>
            <span class="n">resp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">runner</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># These cases can happen when:</span>
            <span class="c1"># * if the user tried to start some work and it threw an exception</span>
            <span class="c1"># * they tried to start an empty work list</span>
            <span class="c1"># * they never tried to start any work</span>
            <span class="c1"># * the worker_id is foobar</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">resp</span>

    <span class="k">def</span> <span class="nf">exposed_gather_ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctxs</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>

            <span class="c1"># Remove stuff we added inline, like the runner</span>
            <span class="n">ctxs_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">walk_ctx</span> <span class="ow">in</span> <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;walk_ctxs&#39;</span><span class="p">]:</span>
                <span class="n">ctx_out</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">walk_ctx</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">,</span> <span class="s1">&#39;walk_ctxs&#39;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctx_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">ctxs_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ctx_out</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ctxs_out</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">exposed_provide_logs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span><span class="p">,</span> <span class="n">copy_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">shutil</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
                <span class="c1"># (probably the same file)</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span><span class="p">,</span> <span class="n">copy_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">shutil</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
                <span class="c1"># (probably the same file)</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose_file_path</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace_file_path</span><span class="p">)</span></div>


<span class="c1">#### Walk runner funcs; the client should probably just call these.</span>
<div class="viewcode-block" id="run_walks"><a class="viewcode-back" href="../../api.html#combtest.runner.run_walks">[docs]</a><span class="k">def</span> <span class="nf">run_walks</span><span class="p">(</span><span class="n">walk_options</span><span class="p">,</span>
              <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
              <span class="n">logger_port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">runner_class</span><span class="o">=</span><span class="n">WalkExecutorService</span><span class="p">,</span>
              <span class="n">service_group_class</span><span class="o">=</span><span class="n">worker</span><span class="o">.</span><span class="n">ServiceGroup</span><span class="p">,</span>
              <span class="n">service_infos</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">service_handler_class</span><span class="o">=</span><span class="n">bootstrap</span><span class="o">.</span><span class="n">ServiceHandler_Local</span><span class="p">,</span>
              <span class="n">gather_ctxs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
              <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">runner_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a collection of :class:`combtest.walk.Walk`. This is one of the main</span>
<span class="sd">    functions that the user should probably be using to run their tests.</span>

<span class="sd">    :param iterable walk_options: An iterable of iterables which produce</span>
<span class="sd">                                  :class:`combtest.action.Action`. Example: a</span>
<span class="sd">                                  list of iterables produced by</span>
<span class="sd">                                  ``MyActionClass.get_option_set()``.</span>
<span class="sd">    :param object ctx: a state/``ctx`` to pass to copy and pass to the</span>
<span class="sd">                       ``Walks`` when we execute them.</span>
<span class="sd">    :param bool verbose: produce a verbose level log, and set the log level to</span>
<span class="sd">                         DEBUG.</span>
<span class="sd">    :param int logger_port: the port number where our local logger should</span>
<span class="sd">                            accept data.</span>
<span class="sd">    :param combtest.worker.CoordinatorService runner_class: the type of Walk</span>
<span class="sd">                                                            execution service</span>
<span class="sd">                                                            to use.</span>
<span class="sd">    :param combtest.worker.ServiceGroup service_group_class: the type of</span>
<span class="sd">                                                             ``ServiceGroup``</span>
<span class="sd">                                                             we will use to</span>
<span class="sd">                                                             coordinate remote</span>
<span class="sd">                                                             executors</span>
<span class="sd">    :param iterable service_infos: An iterable of any extra infos we need to</span>
<span class="sd">                                   bootstrap the remote services. See</span>
<span class="sd">                                   :class:`combtest.bootstrap.ServiceHandleArray`.</span>
<span class="sd">    :param combtest.bootstrap.ServiceHandler service_handler_class: Type of</span>
<span class="sd">                        ``ServiceHandler`` to use to bootstrap the services.</span>
<span class="sd">    :param bool gather_ctxs: if True, gather and return all ``ctxs`` from the</span>
<span class="sd">                             remote services at the end of the run. Will be</span>
<span class="sd">                             returned as a mapping ip-&gt;[ctx, ...]</span>
<span class="sd">    :param int max_thread_count: Max number of ``Walk`` executing threads that</span>
<span class="sd">                                 each service will use.</span>
<span class="sd">    :param runner_kwargs: kwargs to pass to the remote ``WalkRunner``.</span>

<span class="sd">    :raises RuntimeError: when remote services can&#39;t be established and</span>
<span class="sd">                          connected to.</span>
<span class="sd">    :return: count of walks run, count of walk execution errors, total elapsed</span>
<span class="sd">             time, remote ctxs if ``gather_ctxs == True``, else None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">logger_port</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">logger_port</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_logger_port</span><span class="p">()</span>

    <span class="c1"># This allows us to receive logs from the remote side that are any log</span>
    <span class="c1"># level, but it doesn&#39;t actually force the remote side to log at the DEBUG</span>
    <span class="c1"># level. See the verbose argument for how we switch that.</span>
    <span class="n">central_logger</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">central_logger</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="c1"># Set up remote logging w/local printing</span>
    <span class="n">my_ip</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_my_IP</span><span class="p">()</span>

    <span class="n">central_logger</span><span class="o">.</span><span class="n">start_recv_remote_logs</span><span class="p">(</span><span class="n">my_ip</span><span class="p">,</span> <span class="n">logger_port</span><span class="p">)</span>

    <span class="n">sg</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Bring up services across the cluster which can execute Walks in parallel.</span>
        <span class="c1"># See worker.py docs on the wiki for details about how this works.</span>
        <span class="n">service_qualname</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_class_qualname</span><span class="p">(</span><span class="n">runner_class</span><span class="p">)</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Bringing up services&quot;</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">service_group_class</span><span class="p">(</span><span class="n">service_qualname</span><span class="p">,</span>
                                 <span class="n">service_infos</span><span class="o">=</span><span class="n">service_infos</span><span class="p">,</span>
                                 <span class="n">service_handler_class</span><span class="o">=</span><span class="n">service_handler_class</span>
                                <span class="p">)</span>

        <span class="n">sg</span><span class="o">.</span><span class="n">start_remote_logging</span><span class="p">(</span><span class="n">my_ip</span><span class="p">,</span> <span class="n">logger_port</span><span class="p">)</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Services are up&quot;</span><span class="p">)</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">StateCombinator</span><span class="p">(</span><span class="o">*</span><span class="n">walk_options</span><span class="p">)</span>

        <span class="n">ctxs_out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Scattering work&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span> <span class="ow">or</span> <span class="p">{}</span>
            <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">runner_kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c1"># Scatter walks to be run across service instances, to be run in parallel.</span>
            <span class="c1"># This call is asynchronous; we wait for it to finish with the call to</span>
            <span class="c1"># join() below.</span>
            <span class="n">worker_ids</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">scatter_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span>
                                         <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span>
                                         <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span>
                                        <span class="p">)</span>

            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Work sent; waiting for it to finish&quot;</span><span class="p">)</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Work finished; gathering responses&quot;</span><span class="p">)</span>
            <span class="n">resps</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gather_all_resp</span><span class="p">(</span><span class="n">worker_ids</span><span class="p">)</span>
            <span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">resp</span> <span class="ow">in</span> <span class="n">resps</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">resp</span> <span class="ow">or</span> <span class="s1">&#39;count&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;ERROR: did not receive all responses: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                       <span class="nb">str</span><span class="p">(</span><span class="n">resps</span><span class="p">))</span>
                <span class="n">total_count</span> <span class="o">+=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
                <span class="n">error_count</span> <span class="o">+=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;error_count&#39;</span><span class="p">]</span>

            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>

            <span class="k">if</span> <span class="n">gather_ctxs</span><span class="p">:</span>
                <span class="n">ctxs_out</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gather_all_ctxs</span><span class="p">(</span><span class="n">worker_ids</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="n">central_logger</span><span class="o">.</span><span class="n">stop_recv_remote_logs</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">sg</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">hard</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Ran </span><span class="si">%d</span><span class="s2"> walks; </span><span class="si">%d</span><span class="s2"> errors; in </span><span class="si">%0.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
                                  <span class="n">total_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">,</span> <span class="n">ctxs_out</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">stop_recv_remote_logs</span><span class="p">()</span></div>


<span class="c1">#### Multistage walk running</span>
<div class="viewcode-block" id="MultistageWalkRunner"><a class="viewcode-back" href="../../api.html#combtest.runner.MultistageWalkRunner">[docs]</a><span class="k">class</span> <span class="nc">MultistageWalkRunner</span><span class="p">(</span><span class="n">WalkRunner</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similar to ``WalkRunner``, but walks are sent with an id that allows them</span>
<span class="sd">    to reclaim context from a prior ``Walk``. Typically this is used for Walks</span>
<span class="sd">    to be executed in multiple stages: the second stage is sent with an id</span>
<span class="sd">    matching the first.</span>

<span class="sd">    Note:</span>
<span class="sd">        When we say &quot;reclaim context&quot; we are referring to the ``dynamic_ctx`` /</span>
<span class="sd">        ``ctx``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is O(N) in memory, where N is the number of ``Walks`` this runner</span>
    <span class="c1"># is responsible for. That could present a scalability problem if too many</span>
    <span class="c1"># ``Walks`` are run in one shot. Not much we can do unless we start</span>
    <span class="c1"># serializing ctxs and stashing them on disk? That is a big change, though.</span>
    <span class="c1"># Let&#39;s run with this for now.</span>

    <span class="c1"># PORT/WRAP - add self.PANIC</span>
    <span class="k">def</span> <span class="nf">run_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">walk_to_run</span><span class="p">,</span>
                 <span class="n">sync_point</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_walks_ctx</span><span class="p">(</span><span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;cancel&#39;</span> <span class="ow">in</span> <span class="n">ctx</span> <span class="ow">and</span> <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;cancel&#39;</span><span class="p">]:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">sync_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;sync_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sync_point</span>


        <span class="c1"># PORT/WRAP - add self.PANIC</span>
        <span class="c1">#logger.trace_op(test_file=cur_ctx.test_file,</span>
        <span class="c1">#                walk=cur_ctx.walk,</span>
        <span class="c1">#                walk_id=walk_id,</span>
        <span class="c1">#                file_config=cur_ctx[&#39;file_config&#39;])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">trace_op</span><span class="p">(</span><span class="n">walk</span><span class="o">=</span><span class="n">walk_to_run</span><span class="p">,</span>
                        <span class="n">walk_id</span><span class="o">=</span><span class="n">walk_id</span><span class="p">,</span>
                        <span class="n">sync_point</span><span class="o">=</span><span class="n">sync_point</span><span class="p">,</span>
                        <span class="n">branch_id</span><span class="o">=</span><span class="n">branch_id</span><span class="p">)</span>
        <span class="c1">#start_time = time.time()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count_total</span><span class="p">()</span>

        <span class="n">canceled</span> <span class="o">=</span> <span class="n">walk_to_run</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="c1">## Left intentionally for future debugging</span>
        <span class="c1">#logger.debug(&quot;Walk execution took %0.2fs&quot;, time.time() -</span>
        <span class="c1">#        start_time)</span>

        <span class="k">if</span> <span class="n">canceled</span><span class="p">:</span>
            <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;cancel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count_cancel</span><span class="p">()</span>


    <span class="c1"># Singleton</span>
    <span class="n">INSTANCE</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">INSTANCE_LOCK</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">INSTANCE</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">cls</span><span class="o">.</span><span class="n">INSTANCE_LOCK</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">INSTANCE</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">INSTANCE</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">INSTANCE</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultistageWalkRunner</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Maps walk id-&gt;[dynamic_ctx1, dynamic_ctx2, ...]</span>
        <span class="c1"># The reason we have more than one is that we can run a given walk on</span>
        <span class="c1"># multiple files.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">walk_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_walks_ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># PORT/WRAP</span>
        <span class="k">if</span> <span class="n">walk_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">:</span>
            <span class="n">walk_ctx</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="n">walk_ctx</span><span class="p">[</span><span class="s1">&#39;walk_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">walk_id</span>
            <span class="n">walk_ctx</span><span class="p">[</span><span class="s1">&#39;branch_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_id</span>
            <span class="n">walk_ctx</span><span class="p">[</span><span class="s1">&#39;cancel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">walk_ctx</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ctxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_walks_ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_id</span><span class="p">,</span> <span class="n">update_ctx</span><span class="p">):</span>
        <span class="c1"># PORT/WRAP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_ctxs</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">update_ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prep_work_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">walk_to_run</span><span class="p">,</span> <span class="n">sync_point</span> <span class="o">=</span> <span class="n">work</span>

        <span class="k">if</span> <span class="n">sync_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sync_point</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">sync_point</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_walk</span><span class="p">(</span><span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">walk_to_run</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span>
                              <span class="n">sync_point</span><span class="o">=</span><span class="n">sync_point</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CancelWalk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_cancel</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_error</span><span class="p">()</span>
                <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;cancel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">central_logger</span><span class="o">.</span><span class="n">log_remote_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">return</span> <span class="n">run</span></div>

<div class="viewcode-block" id="MultistageWalkRunningService"><a class="viewcode-back" href="../../api.html#combtest.runner.MultistageWalkRunningService">[docs]</a><span class="k">class</span> <span class="nc">MultistageWalkRunningService</span><span class="p">(</span><span class="n">WalkExecutorService</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``WalkExecutorService`` for executing ``Walks`` in multiple stages. That</span>
<span class="sd">    is: we can execute ``Walks`` in parts/slices. A ``walk_id`` is used to</span>
<span class="sd">    refer to the ``Walks`` uniquely.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The &#39;runner&#39; reclaims state associated with the walk and wraps up all the</span>
    <span class="c1"># args/kwargs for the runner func, then calls the runner func.</span>
    <span class="n">RUNNER_TYPE</span> <span class="o">=</span> <span class="n">MultistageWalkRunner</span>

    <span class="k">def</span> <span class="nf">work_repack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;runner&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ctx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;resps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="s1">&#39;runner_opts&#39;</span> <span class="ow">in</span> <span class="n">ctx</span><span class="p">:</span>
                <span class="n">runner_opts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner_opts&#39;</span><span class="p">])</span>
                <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RUNNER_TYPE</span><span class="o">.</span><span class="n">get_instance</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="o">**</span><span class="n">runner_opts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RUNNER_TYPE</span><span class="o">.</span><span class="n">get_instance</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>

        <span class="n">wr</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span>
        <span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">current_walk</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">wr</span><span class="o">.</span><span class="n">prep_work_call</span><span class="p">((</span><span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">current_walk</span><span class="p">,</span>
                                  <span class="n">ctx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sync_point&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">call</span>

    <span class="k">def</span> <span class="nf">exposed_update_remote_contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">walk_ids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctxs</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">walk_id</span> <span class="ow">in</span> <span class="n">walk_ids</span><span class="p">:</span>
                <span class="n">runner</span><span class="o">.</span><span class="n">update_walks_ctx</span><span class="p">(</span><span class="n">walk_id</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not update walk&#39;s context; did an &quot;</span>
                               <span class="s2">&quot;earlier stage fail?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exposed_gather_ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>
            <span class="n">ctxs_out</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">walk_id</span><span class="p">,</span> <span class="n">walk_ctx</span> <span class="ow">in</span> <span class="n">runner</span><span class="o">.</span><span class="n">ctxs</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">ctx_out</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">walk_ctx</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;runner&#39;</span><span class="p">,</span> <span class="s1">&#39;walk_ctxs&#39;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctx_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">ctxs_out</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx_out</span>

            <span class="k">return</span> <span class="n">ctxs_out</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">exposed_gather_resp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">):</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MultistageWalkRunningService</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">exposed_gather_resp</span><span class="p">(</span><span class="n">worker_id</span><span class="p">)</span>

        <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;segment_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
        <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;walk_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runners</span><span class="p">[</span><span class="n">worker_id</span><span class="p">]</span>

            <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;walk_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">walk_count</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># These cases can happen when:</span>
            <span class="c1"># * if the user tried to start some work and it threw an exception</span>
            <span class="c1"># * they tried to start an empty work list</span>
            <span class="c1"># * they never tried to start any work</span>
            <span class="c1"># * the worker_id is foobar</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">resp</span></div>

<div class="viewcode-block" id="ContinuingWalkServiceGroup"><a class="viewcode-back" href="../../api.html#combtest.runner.ContinuingWalkServiceGroup">[docs]</a><span class="k">class</span> <span class="nc">ContinuingWalkServiceGroup</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">ServiceGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ServiceGroup`` designed for running ``Walks`` in stages. We need to be</span>
<span class="sd">    able to run ``Walks`` in stages in order to satisfy the semantic of</span>
<span class="sd">    :class:`combtest.action.SyncPoint` during a run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">WORK_QUANTUM_SIZE</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ContinuingWalkServiceGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Maps walk_id-&gt;(ip, port) of service where that walk&#39;s ctx is</span>
        <span class="c1"># currently held. We track this so we can lock the affinity of a</span>
        <span class="c1"># walk to a single service - allowing us to actually reclaim ctx.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">start_all_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_item</span><span class="p">,</span> <span class="n">shared_ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;You&#39;re using this wrong; use scatter_work&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;You&#39;re using this wrong; use scatter_work&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client_key</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sync_point</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending </span><span class="si">%d</span><span class="s2"> items to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">client_key</span><span class="p">))</span>

        <span class="n">ctx</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">sync_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sync_point</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sync_point</span><span class="p">)</span>
        <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;sync_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sync_point</span>

        <span class="n">worker_id</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">start_work</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                                      <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">queue</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">worker_id</span>

<div class="viewcode-block" id="ContinuingWalkServiceGroup.scatter_work"><a class="viewcode-back" href="../../api.html#combtest.runner.ContinuingWalkServiceGroup.scatter_work">[docs]</a>    <span class="k">def</span> <span class="nf">scatter_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">id_map</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scatter some ``Walk`` segments out to the remote workers.</span>

<span class="sd">        :param iterable epoch: iterable of (walk_id, branch_id, Walk)</span>
<span class="sd">        :param dict id_map: optional map walk_id-&gt;(ip, port) of service</span>
<span class="sd">                            currently holding that Walk&#39;s ctx.</span>
<span class="sd">        :return: an updated ``id_map``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Holds queued work for each IP</span>
        <span class="c1"># Maps client_key-&gt;work queue</span>
        <span class="c1"># Flushed when quantum size is hit, and at tail flush</span>
        <span class="n">out_queues</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">clients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clients</span>

        <span class="n">id_map</span> <span class="o">=</span> <span class="n">id_map</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_map</span>
        <span class="n">key_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clients</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">key_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

        <span class="c1"># Maps (ip, port)-&gt;worker ids</span>
        <span class="n">worker_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">worker_ids</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># NOTE: &#39;walk_to_run&#39; is in-fact (walk_id, branch_id, Walk)</span>
        <span class="k">for</span> <span class="n">walk_to_run</span> <span class="ow">in</span> <span class="n">epoch</span><span class="p">:</span>
            <span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">actual_walk</span> <span class="o">=</span> <span class="n">walk_to_run</span>

            <span class="k">if</span> <span class="n">walk_id</span> <span class="ow">in</span> <span class="n">id_map</span><span class="p">:</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Assign the next client</span>
                <span class="n">target_key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">key_idx</span><span class="p">]</span>
                <span class="n">key_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">key_idx</span> <span class="o">%=</span> <span class="n">key_count</span>
                <span class="n">id_map</span><span class="p">[</span><span class="n">walk_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_key</span>

            <span class="k">if</span> <span class="n">target_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_queues</span><span class="p">:</span>
                <span class="n">out_queues</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_queue</span> <span class="o">=</span> <span class="n">out_queues</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>

            <span class="n">jsonified</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">encode</span><span class="p">((</span><span class="n">walk_id</span><span class="p">,</span> <span class="n">branch_id</span><span class="p">,</span> <span class="n">actual_walk</span><span class="p">))</span>
            <span class="n">current_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jsonified</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_queue</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">WORK_QUANTUM_SIZE</span><span class="p">:</span>
                <span class="n">total_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_queue</span><span class="p">)</span>
                <span class="n">worker_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flush_queue</span><span class="p">(</span><span class="n">target_key</span><span class="p">,</span> <span class="n">clients</span><span class="p">[</span><span class="n">target_key</span><span class="p">],</span>
                        <span class="n">current_queue</span><span class="p">,</span> <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                        <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sync_point</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">sync_point</span><span class="p">)</span>
                <span class="n">worker_ids</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">target_key</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">out_queues</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">clients</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>
            <span class="n">total_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">worker_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flush_queue</span><span class="p">(</span><span class="n">target_key</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span>
                                          <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">,</span>
                                          <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sync_point</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">sync_point</span><span class="p">)</span>
            <span class="n">worker_ids</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker_id</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">id_map</span> <span class="o">=</span> <span class="n">id_map</span>
        <span class="k">return</span> <span class="n">id_map</span><span class="p">,</span> <span class="n">total_count</span><span class="p">,</span> <span class="n">worker_ids</span></div>

<div class="viewcode-block" id="ContinuingWalkServiceGroup.update_remote_contexts"><a class="viewcode-back" href="../../api.html#combtest.runner.ContinuingWalkServiceGroup.update_remote_contexts">[docs]</a>    <span class="k">def</span> <span class="nf">update_remote_contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">worker_ids</span><span class="p">,</span> <span class="n">walk_ids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push an update to the ``ctxs`` on the remote executors. This is</span>
<span class="sd">        sometimes useful when a :class:`combtest.action.SyncPoint` executes and</span>
<span class="sd">        affects some set of ``Walks``.</span>

<span class="sd">        :param str ip: hostname or IP where the remote executor can be found</span>
<span class="sd">        :param iterable worker_ids: iterable of ints, corresponding to</span>
<span class="sd">                                    ``worker_ids`` that can be found on the</span>
<span class="sd">                                    remote executor.</span>
<span class="sd">        :param kwargs: the keys/values to set on the remote ``ctx``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: this makes heavy reliance on the singleton being used on the</span>
        <span class="c1"># other side: all workers are sharing a &#39;runner&#39;</span>
        <span class="n">worker_id</span> <span class="o">=</span> <span class="n">worker_ids</span><span class="p">[</span><span class="n">ip</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clients</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">.</span><span class="n">update_remote_contexts</span><span class="p">(</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">walk_ids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContinuingWalkServiceGroup.gather_all_resp"><a class="viewcode-back" href="../../api.html#combtest.runner.ContinuingWalkServiceGroup.gather_all_resp">[docs]</a>    <span class="k">def</span> <span class="nf">gather_all_resp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gather stats from remote workers. User may want to extend this to</span>
<span class="sd">        include any new stats they think of.</span>

<span class="sd">        :param dict worker_ids: a mapping hostname/ip-&gt;iterable of</span>
<span class="sd">                                ``worker_ids`` from which we should</span>
<span class="sd">                                gather responses.</span>
<span class="sd">        :return: count of Walk segments run, count of Walk execution errors,</span>
<span class="sd">                 count of Walks run</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_segment_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_error_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_walk_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">worker_ids</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">worker_id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_resp</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">resp</span> <span class="ow">or</span> <span class="s1">&#39;segment_count&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;ERROR: did not receive whole &quot;</span>
                                       <span class="s2">&quot;response for </span><span class="si">%s</span><span class="s2">, id </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">resp</span><span class="p">)))</span>
                <span class="n">total_segment_count</span> <span class="o">+=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;segment_count&#39;</span><span class="p">]</span>
                <span class="n">total_error_count</span> <span class="o">+=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;error_count&#39;</span><span class="p">]</span>
                <span class="n">total_walk_count</span> <span class="o">+=</span> <span class="n">resp</span><span class="p">[</span><span class="s1">&#39;walk_count&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">total_segment_count</span><span class="p">,</span> <span class="n">total_error_count</span><span class="p">,</span> <span class="n">total_walk_count</span></div>

<div class="viewcode-block" id="ContinuingWalkServiceGroup.start_remote_logging"><a class="viewcode-back" href="../../api.html#combtest.runner.ContinuingWalkServiceGroup.start_remote_logging">[docs]</a>    <span class="k">def</span> <span class="nf">start_remote_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">log_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">log_namespace</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start logging on all remote services.</span>

<span class="sd">        :param str ip: hostname or ip of local machine, where a log server is</span>
<span class="sd">                       running</span>
<span class="sd">        :param int port: port number of local log server</span>
<span class="sd">        :param str log_dir: path to remote log directory the service should</span>
<span class="sd">                            use</span>
<span class="sd">        :param str log_namespace: prefix for log files</span>
<span class="sd">        :param bool verbose: True to signal debug logging</span>
<span class="sd">        :return: a dict mapping remote service hostname/ip-&gt;remote log file</span>
<span class="sd">                 locations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cur_ip</span><span class="p">,</span> <span class="n">client</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clients</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">client_logs</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">start_remote_logging</span><span class="p">(</span>
                    <span class="n">ip</span><span class="p">,</span>
                    <span class="n">port</span><span class="p">,</span>
                    <span class="n">log_dir</span><span class="o">=</span><span class="n">log_dir</span><span class="p">,</span>
                    <span class="n">log_namespace</span><span class="o">=</span><span class="n">log_namespace</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">logs</span><span class="p">[</span><span class="n">cur_ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">client_logs</span>
        <span class="k">return</span> <span class="n">logs</span></div>

    <span class="k">def</span> <span class="nf">provide_logs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_dir</span><span class="p">):</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">client</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clients</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">client_logs</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">provide_logs</span><span class="p">(</span><span class="n">log_dir</span><span class="p">)</span>
            <span class="n">logs</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">client_logs</span>
        <span class="k">return</span> <span class="n">logs</span></div>

<span class="c1"># TODO: PORT/WRAP</span>
<div class="viewcode-block" id="run_multistage_walks"><a class="viewcode-back" href="../../api.html#combtest.runner.run_multistage_walks">[docs]</a><span class="k">def</span> <span class="nf">run_multistage_walks</span><span class="p">(</span><span class="n">walk_order</span><span class="p">,</span>
                         <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">logger_port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">runner_class</span><span class="o">=</span><span class="n">MultistageWalkRunningService</span><span class="p">,</span>
                         <span class="n">service_group_class</span><span class="o">=</span><span class="n">ContinuingWalkServiceGroup</span><span class="p">,</span>
                         <span class="n">service_infos</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">service_handler_class</span><span class="o">=</span><span class="n">bootstrap</span><span class="o">.</span><span class="n">ServiceHandler_Local</span><span class="p">,</span>
                         <span class="n">max_thread_count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">gather_ctxs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">log_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="c1"># PORT/WRAP test_path=utils.DEFAULT_TEST_PATH,</span>
                         <span class="c1">#**file_config_kwargs,</span>
                        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a collection of :class:`combtest.walk.Walk`. This should be the main</span>
<span class="sd">    way to execute ``Walks`` for most users. This is the only interface that</span>
<span class="sd">    supports correct execution of a :class:`combtest.action.SyncPoint`.</span>

<span class="sd">    :param iterable walk_order: An iterable of iterables which produce</span>
<span class="sd">                                :class:`combtest.action.Action`. Example: a</span>
<span class="sd">                                list of iterables produced by</span>
<span class="sd">                                ``MyActionClass.get_option_set()``.</span>
<span class="sd">    :param object ctx: a state/``ctx`` to pass to copy and pass to the</span>
<span class="sd">                       ``Walks`` when we execute them.</span>
<span class="sd">    :param bool verbose: produce a verbose level log, and set the log level to</span>
<span class="sd">                         DEBUG.</span>
<span class="sd">    :param int logger_port: the port number where our local logger should</span>
<span class="sd">                            accept data.</span>
<span class="sd">    :param combtest.worker.CoordinatorService runner_class: the type of Walk</span>
<span class="sd">                                                            execution service</span>
<span class="sd">                                                            to use.</span>
<span class="sd">    :param combtest.worker.ServiceGroup service_group_class: the type of</span>
<span class="sd">                                                             ``ServiceGroup``</span>
<span class="sd">                                                             we will use to</span>
<span class="sd">                                                             coordinate remote</span>
<span class="sd">                                                             executors</span>
<span class="sd">    :param iterable service_infos: An iterable of any extra infos we need to</span>
<span class="sd">                                   bootstrap the remote services. See</span>
<span class="sd">                                   :class:`combtest.bootstrap.ServiceHandleArray`.</span>
<span class="sd">    :param combtest.bootstrap.ServiceHandler service_handler_class: Type of</span>
<span class="sd">                        ``ServiceHandler`` to use to bootstrap the services.</span>
<span class="sd">    :param bool gather_ctxs: if True, gather and return all ``ctxs`` from the</span>
<span class="sd">                             remote services at the end of the run. Will be</span>
<span class="sd">                             returned as a mapping ip-&gt;[ctx, ...]</span>
<span class="sd">    :param int max_thread_count: Max number of ``Walk`` executing threads that</span>
<span class="sd">                                 each service will use.</span>
<span class="sd">    :param str log_dir: Directory where we will store traces, debug logs, etc.</span>
<span class="sd">                        Remote services will also attempt to store logs to</span>
<span class="sd">                        the same path.</span>

<span class="sd">    :raises RuntimeError: when remote services can&#39;t be established and</span>
<span class="sd">                          connected to.</span>
<span class="sd">    :return: count of walks run, count of walk execution errors, count of walk</span>
<span class="sd">             segments run, total elapsed time, remote ctxs if</span>
<span class="sd">             ``gather_ctxs == True`` else None, the location of the master</span>
<span class="sd">             log file, where applicable.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">logger_port</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">logger_port</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_logger_port</span><span class="p">()</span>

    <span class="c1"># PORT/WRAP</span>
    <span class="c1">#if log_dir is None:</span>
    <span class="c1">#    log_dir = ac_config.get_log_dir()</span>
    <span class="c1">#    if log_dir is None or log_dir == &quot;.&quot;:</span>
    <span class="c1">#        log_dir = &quot;/var/crash&quot;</span>
    <span class="c1">#log_dir = os.path.join(log_dir, SUBDIR_NAME)</span>

    <span class="n">my_ip</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_my_IP</span><span class="p">()</span>
    <span class="c1">#rtt.remote_cmd(my_ip, &#39;isi_for_array &quot;mkdir -p %s&quot;&#39; % log_dir)</span>

    <span class="k">if</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Log files will be at: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">log_dir</span><span class="p">)</span>

        <span class="c1"># Used to give us some data that connects us back to the remote</span>
        <span class="c1"># workers. e.g. where their logs are being stored.</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">add_op_trace</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">central_logger</span><span class="o">.</span><span class="n">OpTracer</span><span class="p">)</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Log master at: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="o">.</span><span class="n">op_trace</span><span class="o">.</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1"># TODO? Pull files back from remote side via rpyc?</span>

    <span class="c1"># This allows us to receive logs from the remote side that are any log</span>
    <span class="c1"># level, but it doesn&#39;t actually force the remote side to log at the DEBUG</span>
    <span class="c1"># level. See the verbose argument for how we switch that.</span>
    <span class="n">central_logger</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">central_logger</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="c1"># Set up remote logging w/local printing</span>
    <span class="n">central_logger</span><span class="o">.</span><span class="n">start_recv_remote_logs</span><span class="p">(</span><span class="n">my_ip</span><span class="p">,</span> <span class="n">logger_port</span><span class="p">)</span>
    <span class="n">ctxs_out</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">sg</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Get the test case generator.</span>
        <span class="n">wo</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">WalkOptions</span><span class="p">(</span><span class="n">walk_order</span><span class="p">)</span>

        <span class="c1"># Bring up services across the cluster which can execute Walks in parallel.</span>
        <span class="c1"># See worker.py docs on the wiki for details about how this works.</span>
        <span class="n">service_qualname</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_class_qualname</span><span class="p">(</span><span class="n">runner_class</span><span class="p">)</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Bringing up services&quot;</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">service_group_class</span><span class="p">(</span><span class="n">service_qualname</span><span class="p">,</span>
                                 <span class="n">service_infos</span><span class="o">=</span><span class="n">service_infos</span><span class="p">,</span>
                                 <span class="n">service_handler_class</span><span class="o">=</span><span class="n">service_handler_class</span>
                                <span class="p">)</span>

        <span class="c1"># PORT/WRAP: pass test_path</span>
        <span class="n">remote_log_locations</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">start_remote_logging</span><span class="p">(</span><span class="n">my_ip</span><span class="p">,</span>
                                                       <span class="n">logger_port</span><span class="p">,</span>
                                                       <span class="n">log_dir</span><span class="p">,</span>
                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1">#            test_path, verbose=verbose)</span>

        <span class="n">master_location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">remote_log_locations</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Remote log locations:&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">trace_op</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;master&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">log_locations</span> <span class="ow">in</span> <span class="n">remote_log_locations</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">trace_op</span><span class="p">(</span><span class="n">ip</span><span class="o">=</span><span class="n">ip</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="n">log_locations</span><span class="p">)</span>
            <span class="n">master_location</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">op_trace</span><span class="o">.</span><span class="n">fname</span>
        <span class="n">master_log</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;master&#39;</span><span class="p">:</span> <span class="n">master_location</span><span class="p">,</span>
                      <span class="s1">&#39;remote&#39;</span><span class="p">:</span> <span class="n">remote_log_locations</span>
                     <span class="p">}</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Services are up&quot;</span><span class="p">)</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Scattering work&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># PORT/WRAP</span>
        <span class="c1">#ctx = {}</span>
        <span class="c1">#if file_config_kwargs:</span>
        <span class="c1">#    ctx[&#39;runner_opts&#39;] = copy.copy(file_config_kwargs)</span>
        <span class="c1">#if verbose:</span>
        <span class="c1">#    ctx[&#39;verbose&#39;] = True</span>

        <span class="c1">#ctx[&#39;test_path&#39;] = test_path</span>
        <span class="c1">#ctx[&#39;log_dir&#39;] = log_dir</span>

        <span class="c1"># central_logger.log_status(&quot;Test path: %s&quot;, test_path)</span>

        <span class="n">master_worker_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">epoch_list</span> <span class="ow">in</span> <span class="n">wo</span><span class="p">:</span>
            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Epoch list has </span><span class="si">%d</span><span class="s2"> epochs&quot;</span><span class="p">,</span>
                                      <span class="nb">len</span><span class="p">(</span><span class="n">epoch_list</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epoch_list</span><span class="p">:</span>
                <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">sync_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># This logic should be pulled into SyncPoint. I don&#39;t like</span>
                    <span class="c1"># that SyncPoint.update_remote_contexts relies on this</span>
                    <span class="c1"># being set up right.</span>
                    <span class="k">for</span> <span class="n">branch_id</span> <span class="ow">in</span> <span class="n">epoch</span><span class="o">.</span><span class="n">branch_ids</span><span class="p">:</span>
                        <span class="c1"># PORT/WRAP</span>
                        <span class="c1">#sp_ctx = {&quot;base_dir&quot;: test_path,</span>
                        <span class="c1">#          &quot;branch_id&quot;: branch_id,</span>
                        <span class="c1">#          &quot;service&quot;: sg,</span>
                        <span class="c1">#          &quot;worker_ids&quot;: master_worker_ids,</span>
                        <span class="c1">#          &quot;epoch&quot;: epoch</span>
                        <span class="c1">#         }</span>
                        <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">sync_point</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx_copy</span><span class="p">,</span>
                                                    <span class="n">branch_id</span><span class="o">=</span><span class="n">branch_id</span><span class="p">,</span>
                                                    <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span>
                                                    <span class="n">service</span><span class="o">=</span><span class="n">sg</span><span class="p">,</span>
                                                    <span class="n">worker_ids</span><span class="o">=</span><span class="n">master_worker_ids</span>
                                                   <span class="p">)</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">worker_ids</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">scatter_work</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx_copy</span><span class="p">,</span>
                                                       <span class="n">max_thread_count</span><span class="o">=</span><span class="n">max_thread_count</span><span class="p">)</span>
                <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Epoch of work sent; &quot;</span>
                                          <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> work items&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">worker_ids</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ip</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">master_worker_ids</span><span class="p">:</span>
                        <span class="n">master_worker_ids</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">master_worker_ids</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>

            <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Epochs started; waiting for &quot;</span>
                                      <span class="s2">&quot;them to finish&quot;</span><span class="p">)</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Work finished; gathering responses&quot;</span><span class="p">)</span>

        <span class="n">segment_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">walk_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">master_worker_ids</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># No work sent, e.g. because we didn&#39;t have many walks</span>
                <span class="k">continue</span>

            <span class="c1"># NOTE: taking advantage of singleton</span>
            <span class="n">wid</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wids</span> <span class="o">=</span> <span class="p">{</span><span class="n">ip</span><span class="p">:</span> <span class="p">[</span><span class="n">wid</span><span class="p">,]}</span>
            <span class="n">current_segment_count</span><span class="p">,</span> <span class="n">current_error_count</span><span class="p">,</span> <span class="n">current_walk_count</span> <span class="o">=</span> \
                    <span class="n">sg</span><span class="o">.</span><span class="n">gather_all_resp</span><span class="p">(</span><span class="n">wids</span><span class="p">)</span>
            <span class="n">segment_count</span> <span class="o">+=</span> <span class="n">current_segment_count</span>
            <span class="n">error_count</span> <span class="o">+=</span> <span class="n">current_error_count</span>
            <span class="n">walk_count</span> <span class="o">+=</span> <span class="n">current_walk_count</span>

        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">log_status</span><span class="p">(</span><span class="s2">&quot;Ran </span><span class="si">%d</span><span class="s2"> walks (</span><span class="si">%d</span><span class="s2"> errors) in </span><span class="si">%0.2f</span><span class="s2">s&quot;</span> <span class="o">%</span>
                                  <span class="p">(</span><span class="n">walk_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">gather_ctxs</span><span class="p">:</span>
            <span class="n">ctxs_out</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gather_all_ctxs</span><span class="p">(</span><span class="n">worker_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">provide_logs</span><span class="p">(</span><span class="n">log_dir</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">central_logger</span><span class="o">.</span><span class="n">stop_recv_remote_logs</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">sg</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">hard</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">walk_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">segment_count</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">,</span> <span class="n">ctxs_out</span><span class="p">,</span>
            <span class="n">master_log</span><span class="p">)</span></div>


<span class="c1"># TODO: PORT/WRAP</span>
<div class="viewcode-block" id="replay_multistage_walk"><a class="viewcode-back" href="../../api.html#combtest.runner.replay_multistage_walk">[docs]</a><span class="k">def</span> <span class="nf">replay_multistage_walk</span><span class="p">(</span><span class="n">walk_to_run</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">log_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a single :class:`combtest.walk.Walk`</span>

<span class="sd">    :param Walk walk_to_run: self evident</span>
<span class="sd">    :param bool step: if True, step Action-by-Action through the Walk; the user</span>
<span class="sd">                      hits a key to proceed to the next Action.</span>
<span class="sd">    :param bool log_errors: log exceptions to the logger if True</span>
<span class="sd">    :param object ctx: state/``ctx`` passed to the Walk for execution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">walk_to_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SyncPoint</span><span class="p">):</span>
                <span class="n">op</span><span class="o">.</span><span class="n">replay</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">op</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)))</span>
                <span class="nb">raw_input</span><span class="p">(</span><span class="s2">&quot;Press key to continue...&quot;</span><span class="p">)</span>

        <span class="c1"># PORT/WRAP if verify:</span>
        <span class="c1"># PORT/WRAP     test_file.verify_nonsparse_logical_all()</span>
    <span class="k">except</span> <span class="n">CancelWalk</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg_ctx</span> <span class="o">=</span> <span class="s2">&quot;Walk was: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">ctx: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">walk_to_run</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">log_errors</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg_ctx</span><span class="p">)</span>

        <span class="n">new_msg</span> <span class="o">=</span> <span class="s2">&quot;Walk failed:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">new_msg</span> <span class="o">+=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
        <span class="n">new_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">msg_ctx</span>
        <span class="n">wfe</span> <span class="o">=</span> <span class="n">WalkFailedError</span><span class="p">(</span><span class="n">new_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">):</span>
            <span class="n">wfe</span><span class="o">.</span><span class="n">errno</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span>
        <span class="k">raise</span> <span class="n">wfe</span>

    <span class="k">return</span> <span class="bp">False</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Matthew J. Bryan (Dell/EMC Isilon).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>