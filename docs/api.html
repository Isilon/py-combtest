<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>py-combtest API reference &mdash; py-combtest 1.0.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="py-combtest 1.0.0.0 documentation" href="index.html" />
    <link rel="prev" title="An Introduction To Combinatoric Test Case Generation (Combtesting)" href="introduction_combtesting.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="py-combtest-api-reference">
<h1>py-combtest API reference<a class="headerlink" href="#py-combtest-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-combtest.action">
<span id="action-module"></span><h2>action module<a class="headerlink" href="#module-combtest.action" title="Permalink to this headline">¶</a></h2>
<p>This module provides the core classes for specifying operations and
systematically generating combinations of them.</p>
<dl class="class">
<dt id="combtest.action.Action">
<em class="property">class </em><code class="descclassname">combtest.action.</code><code class="descname">Action</code><span class="sig-paren">(</span><em>static_ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An Action class bundles a function that performs an operation, and all
the different parameterizations for that operation. The
<a class="reference internal" href="#combtest.action.Action.run" title="combtest.action.Action.run"><code class="xref py py-func docutils literal"><span class="pre">run()</span></code></a> method should be overriden; it performs
the operation. The <a class="reference internal" href="#combtest.action.Action.get_option_set" title="combtest.action.Action.get_option_set"><code class="xref py py-func docutils literal"><span class="pre">get_option_set()</span></code></a>
classmethod should be overriden to provide all the valid parameterizations
of the operation.</p>
<p>If you won&#8217;t know until runtime if an operation is valid, you can test for
that in <code class="docutils literal"><span class="pre">run()</span></code>, and raise a <a class="reference internal" href="#combtest.walk.CancelWalk" title="combtest.walk.CancelWalk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.CancelWalk</span></code></a> exception if
you want to stop executing that Walk right away. You may want to cancel,
for example, if the operation + parameter does not make sense given the
current state of the feature. Giving that a solid example: suppose you are
testing a GUI and it has a control hidden, and suppose the operation is to
interact with that control. In the <code class="docutils literal"><span class="pre">run()</span></code> method you can test for that
condition and raise a <a class="reference internal" href="#combtest.walk.CancelWalk" title="combtest.walk.CancelWalk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.CancelWalk</span></code></a>.</p>
<p>State is represented as an object provided by the user, which will be
passed to <a class="reference internal" href="#combtest.action.Action.run" title="combtest.action.Action.run"><code class="xref py py-func docutils literal"><span class="pre">run()</span></code></a> call.</p>
<dl class="classmethod">
<dt id="combtest.action.Action.from_json">
<em class="property">classmethod </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action.from_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="combtest.action.Action.get_option_set">
<em class="property">classmethod </em><code class="descname">get_option_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action.get_option_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action.get_option_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full parameterization space for this Action type. For
example: if you are testing a GUI and this Action sets the state of a
checkbox, then perhaps this will return <code class="docutils literal"><span class="pre">cls(True)</span></code> and
<code class="docutils literal"><span class="pre">cls(False)</span></code> for &#8216;set the box to checked&#8217; and &#8216;set the box to
unchecked&#8217; respectively.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This returns cls instances, not the parameters themselves.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterable of instances of type cls</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.action.Action.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>static_ctx</em>, <em>dynamic_ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called to actually run the operation. It does not need to be
invoked directly by the user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>static_ctx</strong> (<em>object</em>) &#8211; this represents the paramaterization of the
operation. For example: if you are testing
a GUI and this Action represents &#8220;set
the state of checkbox1&#8221;, then static_ctx
would be the checkbox1 setting.</li>
<li><strong>dynamic_ctx</strong> (<em>object</em>) &#8211; this object is passed along from
Action-to-Action in a given Walk as the
Actions execute. It represents any state
that needs to be provided to the Action,
or which may be modified by the Action.
If you are testing a GUI for example,
perhaps this is a handle to an instance of
the GUI.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:raises <a class="reference internal" href="#combtest.walk.CancelWalk" title="combtest.walk.CancelWalk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.CancelWalk</span></code></a>: the operation can raise
<a class="reference internal" href="#combtest.walk.CancelWalk" title="combtest.walk.CancelWalk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.CancelWalk</span></code></a> to cancel the execution of a
<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a> at this point.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.action.Action.should_cancel">
<code class="descname">should_cancel</code><span class="sig-paren">(</span><em>walk</em>, <em>idx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action.should_cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action.should_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called before a Walk containing this Action is run. This
gives an opportunity to prevent the Walk from running if this
combination just doesn&#8217;t make any sense.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>walk</strong> (<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><em>Walk</em></a>) &#8211; the walk we are in</li>
<li><strong>idx</strong> (<em>int</em>) &#8211; the index we are at in the walk</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if the Walk should not be run, else False</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="combtest.action.Action.static_ctx">
<code class="descname">static_ctx</code><a class="headerlink" href="#combtest.action.Action.static_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>This instance&#8217;s parameters, as passed to the initializer.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.action.Action.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#Action.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.Action.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Return something JSONifiable that can uniquely represent this instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.action.OptionSet">
<em class="property">class </em><code class="descclassname">combtest.action.</code><code class="descname">OptionSet</code><span class="sig-paren">(</span><em>options</em>, <em>action_class</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#OptionSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.OptionSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An <a class="reference internal" href="#combtest.action.OptionSet" title="combtest.action.OptionSet"><code class="xref py py-class docutils literal"><span class="pre">OptionSet</span></code></a> is an iterable that provides instances of a given
<a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a> class. This is typically used as a return
value from an Action&#8217;s <code class="xref py py-func docutils literal"><span class="pre">get_option_set()</span></code> method.</p>
<dl class="classmethod">
<dt id="combtest.action.OptionSet.from_json">
<em class="property">classmethod </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#OptionSet.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.OptionSet.from_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="combtest.action.OptionSet.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#OptionSet.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.OptionSet.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Lazy iteration, meaning: generate the actual Actions on the fly to
try to minimize mem footprint.
:raise StopIteration: when the underlying options iterator is exhausted</p>
</dd></dl>

<dl class="method">
<dt id="combtest.action.OptionSet.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#OptionSet.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.OptionSet.to_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.action.SyncPoint">
<em class="property">class </em><code class="descclassname">combtest.action.</code><code class="descname">SyncPoint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#SyncPoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.SyncPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a></p>
<p>A SyncPoint is a type of Action which cannot be run in parallel with
others, e.g. for when we are running a bunch of &#8216;Walks&#8217; in parallel.
Thinking in terms of parallel algorithms: this represents a pinch point
where an operation must be serialized with everything else. In terms of
testing: it is part of a test where we can&#8217;t run other cases in parallel;
e.g. if we are twiddling some global config option that affects all running
test cases.</p>
<p>Fundamentally, a SyncPoint is run a single time for a given
parameterization, regardless of how many Walks contain it. The part of the
Walks prior to the SyncPoint will be run first.</p>
<dl class="docutils">
<dt>Example: suppose we have three Walks:</dt>
<dd><ul class="first simple">
<li>[Action1(1), Action2(2), SyncPoint1(1), Action3(3)],</li>
<li>[Action1(1), Action2(3), SyncPoint1(1), Action3(3)],</li>
<li>[Action1(1), Action2(2), Action3(3), SyncPoint1(1), Action4(4)]</li>
</ul>
<p>We can run the first &#8216;segment&#8217; of each Walk in parallel:
* [Action1(1), Action2(2)],
* [Action1(1), Action2(3)],
* [Action1(1), Action2(2), Action3(3)]</p>
<p class="last">Then, single a thread we will run SyncPoint1(1), then in parallal we
can run:
* [Action3(3)],
* [Action3(3)],
* [Action4(4)]</p>
</dd>
</dl>
<dl class="method">
<dt id="combtest.action.SyncPoint.replay">
<code class="descname">replay</code><span class="sig-paren">(</span><em>dynamic_ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#SyncPoint.replay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.SyncPoint.replay" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="combtest.action.SyncPoint.run_as_replay">
<code class="descname">run_as_replay</code><span class="sig-paren">(</span><em>static_ctx</em>, <em>dynamic_ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#SyncPoint.run_as_replay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.SyncPoint.run_as_replay" title="Permalink to this definition">¶</a></dt>
<dd><p>When a SyncPoint is run during a Walk replay, its execution looks much
more like a vanilla Action. sometimes the logic needs to be slightly
different for a replay, e.g. because there is no remote context to
update. So if you intend to ever replay a Walk, you may want to
override this. Otherwise, it acts just like <code class="xref py py-func docutils literal"><span class="pre">run()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.action.SyncPoint.update_remote_contexts">
<code class="descname">update_remote_contexts</code><span class="sig-paren">(</span><em>dynamic_ctx</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#SyncPoint.update_remote_contexts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.SyncPoint.update_remote_contexts" title="Permalink to this definition">¶</a></dt>
<dd><p>Fundamentally, SyncPoints are run a single time for each
parameterization, as explained above. SyncPoint instances can
be executed in a totally different memory space than the rest of a
<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a> (e.g. due to using remote executors; see
<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.ServiceGroup</span></code></a>). So to update the state/<code class="docutils literal"><span class="pre">ctx</span></code>
passed along with the Walk, the run() method can call this function to
push an update to the Walk&#8217;s remote context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dynamic_ctx</strong> (<em>object</em>) &#8211; this is the local state that was passed to
the <code class="xref py py-func docutils literal"><span class="pre">run()</span></code> function.</li>
<li><strong>kwargs</strong> &#8211; these are key/value pairs to be pushed to the remote
state/<code class="docutils literal"><span class="pre">ctx</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="combtest.action.get_random_action_by_class">
<code class="descclassname">combtest.action.</code><code class="descname">get_random_action_by_class</code><span class="sig-paren">(</span><em>action_class</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/action.html#get_random_action_by_class"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.action.get_random_action_by_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an instance of the given <a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">Action</span></code></a>, randomly chosen from the set
its <a class="reference internal" href="#combtest.action.Action.get_option_set" title="combtest.action.Action.get_option_set"><code class="xref py py-func docutils literal"><span class="pre">Action.get_option_set()</span></code></a> produces.
:return: An instance of <code class="docutils literal"><span class="pre">action_class</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="module-combtest.bootstrap">
<span id="bootstrap-module"></span><h2>bootstrap module<a class="headerlink" href="#module-combtest.bootstrap" title="Permalink to this headline">¶</a></h2>
<p>We need some way to bootstrap the rpyc-based
<a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.CoordinatorService</span></code></a>. That can include bootstrapping it
on a remote node if we want to take advantage of a whole cluster. We don&#8217;t need
to make too many assumptions to do so. Let&#8217;s provide a general interface for
accomplishing this (<a class="reference internal" href="#combtest.bootstrap.ServiceHandleArray" title="combtest.bootstrap.ServiceHandleArray"><code class="xref py py-class docutils literal"><span class="pre">ServiceHandleArray</span></code></a>), and a base implementation for
bootstrapping locally using <code class="docutils literal"><span class="pre">multiprocessing</span></code>
(<a class="reference internal" href="#combtest.bootstrap.ServiceHandler_Local" title="combtest.bootstrap.ServiceHandler_Local"><code class="xref py py-class docutils literal"><span class="pre">ServiceHandler_Local</span></code></a>). The client can swap out <code class="docutils literal"><span class="pre">ServiceHandlers</span></code> to
provide alternative bootstrapping logic. <code class="docutils literal"><span class="pre">ServiceHandleArray</span></code> and
<code class="docutils literal"><span class="pre">ServiceHandler</span></code> simply provide the interface that a
<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.ServiceGroup</span></code></a> uses to bootstrap the service instances.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>A paramiko-based <code class="docutils literal"><span class="pre">ServiceHandler</span></code> class for SSH connections can be
found in <a class="reference internal" href="#combtest.ssh_handle.ServiceHandler_SSH" title="combtest.ssh_handle.ServiceHandler_SSH"><code class="xref py py-class docutils literal"><span class="pre">combtest.ssh_handle.ServiceHandler_SSH</span></code></a>.</dd>
</dl>
<dl class="class">
<dt id="combtest.bootstrap.ConnectionInfo">
<em class="property">class </em><code class="descclassname">combtest.bootstrap.</code><code class="descname">ConnectionInfo</code><span class="sig-paren">(</span><em>ip</em>, <em>port</em>, <em>service_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ConnectionInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ConnectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This is a simple struct-like object meant to wrap all the stuff needed to
bootstrap a service.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ip</strong> (<em>str</em>) &#8211; A string that can be passed as the first argument to
<code class="docutils literal"><span class="pre">rpyc.connect</span></code>. Typically this will be an IP address for
our purposes, but could also be a hostname.</li>
<li><strong>port</strong> (<em>int</em>) &#8211; The port number where the service can be found</li>
<li><strong>service_info</strong> (<em>object</em>) &#8211; Additional information your class may need for
bootstrapping the service. For the SSH
implementation for example, these will be some
authentication bits.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="combtest.bootstrap.ServiceHandleArray">
<em class="property">class </em><code class="descclassname">combtest.bootstrap.</code><code class="descname">ServiceHandleArray</code><span class="sig-paren">(</span><em>connection_infos</em>, <em>spawn=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A ServiceHandlerArray is a collection of ServiceHandlers, together with
dynamic foreach-style dispatch on attribute access. Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sa</span><span class="o">.</span><span class="n">ServiceHandleArray</span><span class="p">(</span><span class="n">blah</span> <span class="n">blah</span> <span class="n">blah</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sa</span><span class="o">.</span><span class="n">q</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>this will dispatch an access to the <code class="docutils literal"><span class="pre">q</span></code> attribute of each contained
<code class="docutils literal"><span class="pre">ServiceHandler</span></code> in parallel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection_infos</strong> (<em>iterable</em>) &#8211; An iterable of <a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><code class="xref py py-class docutils literal"><span class="pre">ConnectionInfo</span></code></a>
which describe how we will start the
services up.</li>
<li><strong>spawn</strong> (<em>bool</em>) &#8211; True if we should spawn the services during
initialization, False otherwise. The user can later
spawn them manually using <a class="reference internal" href="#combtest.bootstrap.ServiceHandleArray.spawn" title="combtest.bootstrap.ServiceHandleArray.spawn"><code class="xref py py-func docutils literal"><span class="pre">spawn()</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="combtest.bootstrap.ServiceHandleArray.REMOTE_CONNECTION_CLASS">
<code class="descname">REMOTE_CONNECTION_CLASS</code><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.REMOTE_CONNECTION_CLASS" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#combtest.bootstrap.ServiceHandler" title="combtest.bootstrap.ServiceHandler"><code class="xref py py-class docutils literal"><span class="pre">ServiceHandler</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="combtest.bootstrap.ServiceHandleArray.attach">
<code class="descname">attach</code><span class="sig-paren">(</span><em>connection_info</em>, <em>instance</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray.attach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a single instance to this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.bootstrap.ServiceHandleArray.is_alive">
<code class="descname">is_alive</code><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.is_alive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if we have any connections, False otherwise. This is
not directly related to whether the services are up; e.g.
they may have died for some reason.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.bootstrap.ServiceHandleArray.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><em>hard=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray.shutdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown all instances this array is tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hard</strong> (<em>bool</em>) &#8211; if False, we will assert that instances shut down
cleanly, otherwise we won&#8217;t.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="combtest.bootstrap.ServiceHandleArray.shutdown_all">
<em class="property">classmethod </em><code class="descname">shutdown_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray.shutdown_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.shutdown_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown all arrays which have not yet been shut down.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.bootstrap.ServiceHandleArray.spawn">
<code class="descname">spawn</code><span class="sig-paren">(</span><em>connection_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray.spawn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.spawn" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn a single instance and attach it to this array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>connection_info</strong> (<a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><em>ConnectionInfo</em></a>) &#8211; The ConnectionInfo that
describes how to start this
instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.bootstrap.ServiceHandleArray.spawn_many">
<code class="descname">spawn_many</code><span class="sig-paren">(</span><em>connection_infos=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandleArray.spawn_many"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandleArray.spawn_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn and attach a bunch of instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>connection_infos</strong> (<em>iterable</em>) &#8211; if None, we will spawn using the
<a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><code class="xref py py-class docutils literal"><span class="pre">ConnectionInfo</span></code></a> s passed to
the initializer. Otherwise,
<code class="docutils literal"><span class="pre">connection_infos</span></code> should be an
iterable of <code class="docutils literal"><span class="pre">ConnectionInfos</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.bootstrap.ServiceHandler">
<em class="property">class </em><code class="descclassname">combtest.bootstrap.</code><code class="descname">ServiceHandler</code><span class="sig-paren">(</span><em>connection_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A <code class="docutils literal"><span class="pre">ServiceHandler</span></code> implements a way of bootstrapping an rpyc-based
service. This base class defines the interface and should be overridden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>connection_info</strong> (<a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><em>ConnectionInfo</em></a>) &#8211; Specifies where the service should
be contactable once it is
bootstrapped, and any additional
information needed to bootstrap it.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="combtest.bootstrap.ServiceHandler.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandler.shutdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandler.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to shut the service down. Should be idempotent unless the class
writer is <em>very</em> careful about how they shut their services down
manually. The overridden method should call the super-method.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.bootstrap.ServiceHandler.start_cmd">
<code class="descname">start_cmd</code><span class="sig-paren">(</span><em>service_class</em>, <em>service_run_func='combtest.worker.start_service_by_name'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandler.start_cmd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandler.start_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be called to actually do the bootstrapping work. It
should be overridden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>service_class</strong> (<em>&lt;str|rpyc.Service&gt;</em>) &#8211; A full __qualname__ of the
service we are bootstrapping,
or the class itself.</li>
<li><strong>service_run_func</strong> (<em>str</em>) &#8211; optional override of the function that
will be used on the remote side to start
the service up. Needs to be a __qualname__.
Typically this can be left default.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.bootstrap.ServiceHandler_Local">
<em class="property">class </em><code class="descclassname">combtest.bootstrap.</code><code class="descname">ServiceHandler_Local</code><span class="sig-paren">(</span><em>connection_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/bootstrap.html#ServiceHandler_Local"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.bootstrap.ServiceHandler_Local" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.bootstrap.ServiceHandler" title="combtest.bootstrap.ServiceHandler"><code class="xref py py-class docutils literal"><span class="pre">combtest.bootstrap.ServiceHandler</span></code></a></p>
<p>A ServiceHandler implementation foor bootstrapping locally via simple
multiprocessing.Process call out.</p>
</dd></dl>

</div>
<div class="section" id="module-combtest.config">
<span id="config-module"></span><h2>config module<a class="headerlink" href="#module-combtest.config" title="Permalink to this headline">¶</a></h2>
<p>Getters, setters, and loaders of config. Config includes e.g. SSH
authentication stuff, port numbers to use, etc.</p>
<p>There are two layers of config provided: config loaded from file via
<code class="docutils literal"><span class="pre">refresh_cfg</span></code>, and runtime-provided overrides to those. The getters given
below will enforce that ordering. The user provides overrides via the setters.</p>
<dl class="data">
<dt id="combtest.config.CONFIG_LOC">
<code class="descclassname">combtest.config.</code><code class="descname">CONFIG_LOC</code><em class="property"> = 'combtest.cfg'</em><a class="headerlink" href="#combtest.config.CONFIG_LOC" title="Permalink to this definition">¶</a></dt>
<dd><p>Location of a config file to load, if the user wants to load config values
that way</p>
</dd></dl>

<dl class="data">
<dt id="combtest.config.DEFAULT_LOGGER_PORT">
<code class="descclassname">combtest.config.</code><code class="descname">DEFAULT_LOGGER_PORT</code><em class="property"> = 6186</em><a class="headerlink" href="#combtest.config.DEFAULT_LOGGER_PORT" title="Permalink to this definition">¶</a></dt>
<dd><p>Default port number for interproc communication for the logger</p>
</dd></dl>

<dl class="data">
<dt id="combtest.config.DEFAULT_MAX_THREAD_COUNT">
<code class="descclassname">combtest.config.</code><code class="descname">DEFAULT_MAX_THREAD_COUNT</code><em class="property"> = 72</em><a class="headerlink" href="#combtest.config.DEFAULT_MAX_THREAD_COUNT" title="Permalink to this definition">¶</a></dt>
<dd><p>Default number of workers executing a <code class="docutils literal"><span class="pre">combtest.walk.Walk</span></code> at a time
for a given service instance.</p>
</dd></dl>

<dl class="data">
<dt id="combtest.config.DEFAULT_SERVICE_PORT">
<code class="descclassname">combtest.config.</code><code class="descname">DEFAULT_SERVICE_PORT</code><em class="property"> = 6187</em><a class="headerlink" href="#combtest.config.DEFAULT_SERVICE_PORT" title="Permalink to this definition">¶</a></dt>
<dd><p>Default port an rpyc service should listen on e.g. if we start up a remote
service</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_logger_port">
<code class="descclassname">combtest.config.</code><code class="descname">get_logger_port</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_logger_port"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_logger_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the port we will expose locally for remote loggers to connect to.</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_machine_ips">
<code class="descclassname">combtest.config.</code><code class="descname">get_machine_ips</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_machine_ips"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_machine_ips" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of IPs where we should try to set services up</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_max_thread_count">
<code class="descclassname">combtest.config.</code><code class="descname">get_max_thread_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_max_thread_count"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_max_thread_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max thread count for <a class="reference internal" href="#combtest.worker.ThreadPool" title="combtest.worker.ThreadPool"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.ThreadPool</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_service_port">
<code class="descclassname">combtest.config.</code><code class="descname">get_service_port</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_service_port"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_service_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the port number where we should expect to find an rpyc service running,
once it is bootstrapped.</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_ssh_options">
<code class="descclassname">combtest.config.</code><code class="descname">get_ssh_options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_ssh_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_ssh_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all SSH authentication options in a single call.
:returns: a dict of options</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_ssh_passwords">
<code class="descclassname">combtest.config.</code><code class="descname">get_ssh_passwords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_ssh_passwords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_ssh_passwords" title="Permalink to this definition">¶</a></dt>
<dd><p>Get passwords for SSH authentication.
:return: password, map of ip-&gt;password</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_ssh_rsa_keys">
<code class="descclassname">combtest.config.</code><code class="descname">get_ssh_rsa_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_ssh_rsa_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_ssh_rsa_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Get paths to RSA keys that we can use for SSH authentication. This can
include a single file, or one file per e.g. IP.
:return: path, map of ip-&gt;path</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.get_ssh_usernames">
<code class="descclassname">combtest.config.</code><code class="descname">get_ssh_usernames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#get_ssh_usernames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.get_ssh_usernames" title="Permalink to this definition">¶</a></dt>
<dd><p>Get usernames for SSH authentication.
:return: username, map of ip-&gt;username</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.refresh_cfg">
<code class="descclassname">combtest.config.</code><code class="descname">refresh_cfg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#refresh_cfg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.refresh_cfg" title="Permalink to this definition">¶</a></dt>
<dd><p>Call to refresh config loaded from file.</p>
</dd></dl>

<dl class="function">
<dt id="combtest.config.set_service_port">
<code class="descclassname">combtest.config.</code><code class="descname">set_service_port</code><span class="sig-paren">(</span><em>port</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/config.html#set_service_port"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.config.set_service_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the port number where we should expect to find an rpyc service running,
once it is bootstrapped.</p>
</dd></dl>

</div>
<div class="section" id="module-combtest.encode">
<span id="encode-module"></span><h2>encode module<a class="headerlink" href="#module-combtest.encode" title="Permalink to this headline">¶</a></h2>
<p>Easy serialization/deserialization mechanism using JSON. It uses a pair of
methods: an instance level <code class="docutils literal"><span class="pre">to_json()</span></code> method and a classmethod
<code class="docutils literal"><span class="pre">from_json()</span></code> which are used, when available, to convert b/w an instance and
JSON.</p>
<p>We use this mechanism to serialize <a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a> and
<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a> instances for printing to a trace file, or other
logs where human readability is handy.  The reason we don&#8217;t use a custom
encoder/decoder pair for those two classes is that the user can attach a
static_ctx which has no default JSON behavior.  We let them write <code class="docutils literal"><span class="pre">to_json()</span></code>
etc. if they want <code class="docutils literal"><span class="pre">static_ctx</span></code> to be a member of a custom class.</p>
<dl class="function">
<dt id="combtest.encode.decode">
<code class="descclassname">combtest.encode.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>json_str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/encode.html#decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.encode.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a JSON string which was provided by <a class="reference internal" href="#combtest.encode.encode" title="combtest.encode.encode"><code class="xref py py-func docutils literal"><span class="pre">encode()</span></code></a>. Will leverage
a cache for single-instancing <code class="docutils literal"><span class="pre">Actions</span></code>. An <code class="docutils literal"><span class="pre">Action</span></code> is defined by a
single, immutable <code class="docutils literal"><span class="pre">static_ctx</span></code>, so we are safe to use interning.</p>
</dd></dl>

<dl class="function">
<dt id="combtest.encode.encode">
<code class="descclassname">combtest.encode.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/encode.html#encode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.encode.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return JSON equivalent to the provided obj, if possible.
Will raise TypeError if it isn&#8217;t possible.</p>
</dd></dl>

</div>
<div class="section" id="module-combtest.forkjoin">
<span id="forkjoin-module"></span><h2>forkjoin module<a class="headerlink" href="#module-combtest.forkjoin" title="Permalink to this headline">¶</a></h2>
<p>Simple fork/join implementation, modelled after Java&#8217;s lib for the same. This
doesn&#8217;t attempt to make any scheduling optimizations for e.g. the sake of
minimizing makespan. Threads simply share a queue and pop work off of it until
the queue is drained.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This is not designed well for bytecode-level work. This is for I/O heavy
work like e.g. performing network roundtrips, doing disk I/O, etc. If you
need to dodge the GIL, you&#8217;ll want to use something else.</dd>
</dl>
<dl class="class">
<dt id="combtest.forkjoin.WorkItem">
<em class="property">class </em><code class="descclassname">combtest.forkjoin.</code><code class="descname">WorkItem</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/forkjoin.html#WorkItem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.forkjoin.WorkItem" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple container representing a work item to be done.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> (<em>function</em>) &#8211; A pointer to the work callback</li>
<li><strong>args</strong> &#8211; args to pass to the work callback</li>
<li><strong>kwargs</strong> &#8211; kwargs to pass to the work callback</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.forkjoin.fork_join">
<code class="descclassname">combtest.forkjoin.</code><code class="descname">fork_join</code><span class="sig-paren">(</span><em>work</em>, <em>suppress_errors=False</em>, <em>max_spawn_threads=60</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/forkjoin.html#fork_join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.forkjoin.fork_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Poor man&#8217;s fork/join implementation.  Run all work items in parallel up to some
maximum number of simultaneous threads.  Wait for all work to finish, then
return results.  Maximum number of threads that will run in parallel
for a given job will be max_spawn_threads.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work</strong> (<em>iterable</em>) &#8211; an iterable of WorkItems that supports direct
indexing and len</li>
<li><strong>suppress_errors</strong> (<em>bool</em>) &#8211; if False, we will print any exceptions to
stderr, otherwise we won&#8217;t. Does not affect
the return value.</li>
<li><strong>max_spawn_threads</strong> (<em>int</em>) &#8211; The max number of threads running
simultaneously.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of returned items, in 1:1 correspondence to the WorkItems
in &#8216;work&#8217;. That is: the first result corresponds to the first
WorkItem, etc. If nothing is explicitly returned by an item,
its &#8216;return value&#8217; in this list will be None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-combtest.replay">
<span id="replay-module"></span><h2>replay module<a class="headerlink" href="#module-combtest.replay" title="Permalink to this headline">¶</a></h2>
<p>Methods for replaying a <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>. Used via function call, or
main. This includes the ability to replay the <code class="docutils literal"><span class="pre">Walk</span></code> from a trace file
produced during a run.</p>
<dl class="function">
<dt id="combtest.replay.load_from_master">
<code class="descclassname">combtest.replay.</code><code class="descname">load_from_master</code><span class="sig-paren">(</span><em>log_file</em>, <em>walk_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/replay.html#load_from_master"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.replay.load_from_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a <code class="docutils literal"><span class="pre">Walk</span></code> from a master log file. A master log file provides paths to
trace files which were produced by <code class="docutils literal"><span class="pre">Walk</span></code> running services. This presumes
the trace files are available locally, so if they were produced on a remote
node, you&#8217;ll need to make them available by whatever method you prefer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_file</strong> (<em>str</em>) &#8211; a path to the master log file</li>
<li><strong>walk_id</strong> (<em>int</em>) &#8211; a <code class="docutils literal"><span class="pre">walk_id</span></code> which appears in the trace file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.replay.load_from_trace">
<code class="descclassname">combtest.replay.</code><code class="descname">load_from_trace</code><span class="sig-paren">(</span><em>trace_file</em>, <em>walk_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/replay.html#load_from_trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.replay.load_from_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a <code class="docutils literal"><span class="pre">Walk</span></code> from a trace file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>trace_file</strong> (<em>str</em>) &#8211; a path to the trace file</li>
<li><strong>walk_id</strong> (<em>int</em>) &#8211; a <code class="docutils literal"><span class="pre">walk_id</span></code> which appears in the trace file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.replay.replay_walk">
<code class="descclassname">combtest.replay.</code><code class="descname">replay_walk</code><span class="sig-paren">(</span><em>walk_to_run</em>, <em>step=False</em>, <em>replay_func_qualname=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/replay.html#replay_walk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.replay.replay_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a single <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk_to_run</strong> (<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><em>Walk</em></a>) &#8211; self evident</li>
<li><strong>step</strong> (<em>bool</em>) &#8211; if True, step Action-by-Action through the Walk; the user
hits a key to proceed to the next Action.</li>
<li><strong>replay_func_qualname</strong> (<em>str</em>) &#8211; qualname of a replay function to use.
Typically this will be
<a class="reference internal" href="#combtest.runner.replay_multistage_walk" title="combtest.runner.replay_multistage_walk"><code class="xref py py-func docutils literal"><span class="pre">combtest.runner.replay_multistage_walk()</span></code></a>,
but the user is free to provide their own.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; state/<code class="docutils literal"><span class="pre">ctx</span></code> passed to the Walk for execution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.replay.replay_walk_by_id">
<code class="descclassname">combtest.replay.</code><code class="descname">replay_walk_by_id</code><span class="sig-paren">(</span><em>log_file</em>, <em>walk_id</em>, <em>step=False</em>, <em>replay_func_qualname=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/replay.html#replay_walk_by_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.replay.replay_walk_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a single <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>. Load it by deserializing it from
a trace file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_file</strong> (<em>str</em>) &#8211; path to either a master log file or trace file</li>
<li><strong>walk_id</strong> (<em>int</em>) &#8211; a walk_id that appears in the trace file, or one of the
trace files referenced by the master log file.</li>
<li><strong>step</strong> (<em>bool</em>) &#8211; if True, step Action-by-Action through the Walk; the user
hits a key to proceed to the next Action.</li>
<li><strong>replay_func_qualname</strong> (<em>str</em>) &#8211; qualname of a replay function to use.
Typically this will be
<a class="reference internal" href="#combtest.runner.replay_multistage_walk" title="combtest.runner.replay_multistage_walk"><code class="xref py py-func docutils literal"><span class="pre">combtest.runner.replay_multistage_walk()</span></code></a>,
but the user is free to provide their own.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; state/<code class="docutils literal"><span class="pre">ctx</span></code> passed to the Walk for execution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-combtest.runner">
<span id="runner-module"></span><h2>runner module<a class="headerlink" href="#module-combtest.runner" title="Permalink to this headline">¶</a></h2>
<p>This module provides a set of tools for running Walks. This includes running
Walks in stages using e.g. SyncPoints, and ways to run Walks in parallel across
a cluster.</p>
<dl class="class">
<dt id="combtest.runner.ContinuingWalkServiceGroup">
<em class="property">class </em><code class="descclassname">combtest.runner.</code><code class="descname">ContinuingWalkServiceGroup</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#ContinuingWalkServiceGroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.ContinuingWalkServiceGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.ServiceGroup</span></code></a></p>
<p>A <code class="docutils literal"><span class="pre">ServiceGroup</span></code> designed for running <code class="docutils literal"><span class="pre">Walks</span></code> in stages. We need to be
able to run <code class="docutils literal"><span class="pre">Walks</span></code> in stages in order to satisfy the semantic of
<a class="reference internal" href="#combtest.action.SyncPoint" title="combtest.action.SyncPoint"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.SyncPoint</span></code></a> during a run.</p>
<dl class="method">
<dt id="combtest.runner.ContinuingWalkServiceGroup.gather_all_resp">
<code class="descname">gather_all_resp</code><span class="sig-paren">(</span><em>worker_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#ContinuingWalkServiceGroup.gather_all_resp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.ContinuingWalkServiceGroup.gather_all_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather stats from remote workers. User may want to extend this to
include any new stats they think of.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_ids</strong> (<em>dict</em>) &#8211; a mapping hostname/ip-&gt;iterable of
<code class="docutils literal"><span class="pre">worker_ids</span></code> from which we should
gather responses.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">count of Walk segments run, count of Walk execution errors,
count of Walks run</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.ContinuingWalkServiceGroup.scatter_work">
<code class="descname">scatter_work</code><span class="sig-paren">(</span><em>epoch</em>, <em>id_map=None</em>, <em>max_thread_count=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#ContinuingWalkServiceGroup.scatter_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.ContinuingWalkServiceGroup.scatter_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatter some <code class="docutils literal"><span class="pre">Walk</span></code> segments out to the remote workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>epoch</strong> (<em>iterable</em>) &#8211; iterable of (walk_id, branch_id, Walk)</li>
<li><strong>id_map</strong> (<em>dict</em>) &#8211; optional map walk_id-&gt;(ip, port) of service
currently holding that Walk&#8217;s ctx.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an updated <code class="docutils literal"><span class="pre">id_map</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.ContinuingWalkServiceGroup.start_remote_logging">
<code class="descname">start_remote_logging</code><span class="sig-paren">(</span><em>ip</em>, <em>port</em>, <em>log_dir=None</em>, <em>log_namespace=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#ContinuingWalkServiceGroup.start_remote_logging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.ContinuingWalkServiceGroup.start_remote_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Start logging on all remote services.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ip</strong> (<em>str</em>) &#8211; hostname or ip of local machine, where a log server is
running</li>
<li><strong>port</strong> (<em>int</em>) &#8211; port number of local log server</li>
<li><strong>log_dir</strong> (<em>str</em>) &#8211; path to remote log directory the service should
use</li>
<li><strong>log_namespace</strong> (<em>str</em>) &#8211; prefix for log files</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; True to signal debug logging</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict mapping remote service hostname/ip-&gt;remote log file
locations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.ContinuingWalkServiceGroup.update_remote_contexts">
<code class="descname">update_remote_contexts</code><span class="sig-paren">(</span><em>ip</em>, <em>worker_ids</em>, <em>walk_ids</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#ContinuingWalkServiceGroup.update_remote_contexts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.ContinuingWalkServiceGroup.update_remote_contexts" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an update to the <code class="docutils literal"><span class="pre">ctxs</span></code> on the remote executors. This is
sometimes useful when a <a class="reference internal" href="#combtest.action.SyncPoint" title="combtest.action.SyncPoint"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.SyncPoint</span></code></a> executes and
affects some set of <code class="docutils literal"><span class="pre">Walks</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ip</strong> (<em>str</em>) &#8211; hostname or IP where the remote executor can be found</li>
<li><strong>worker_ids</strong> (<em>iterable</em>) &#8211; iterable of ints, corresponding to
<code class="docutils literal"><span class="pre">worker_ids</span></code> that can be found on the
remote executor.</li>
<li><strong>kwargs</strong> &#8211; the keys/values to set on the remote <code class="docutils literal"><span class="pre">ctx</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.runner.MultistageWalkRunner">
<em class="property">class </em><code class="descclassname">combtest.runner.</code><code class="descname">MultistageWalkRunner</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#MultistageWalkRunner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.MultistageWalkRunner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.runner.WalkRunner" title="combtest.runner.WalkRunner"><code class="xref py py-class docutils literal"><span class="pre">combtest.runner.WalkRunner</span></code></a></p>
<p>Similar to <code class="docutils literal"><span class="pre">WalkRunner</span></code>, but walks are sent with an id that allows them
to reclaim context from a prior <code class="docutils literal"><span class="pre">Walk</span></code>. Typically this is used for Walks
to be executed in multiple stages: the second stage is sent with an id
matching the first.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>When we say &#8220;reclaim context&#8221; we are referring to the <code class="docutils literal"><span class="pre">dynamic_ctx</span></code> /
<code class="docutils literal"><span class="pre">ctx</span></code>.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="combtest.runner.MultistageWalkRunningService">
<em class="property">class </em><code class="descclassname">combtest.runner.</code><code class="descname">MultistageWalkRunningService</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#MultistageWalkRunningService"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.MultistageWalkRunningService" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.runner.WalkExecutorService" title="combtest.runner.WalkExecutorService"><code class="xref py py-class docutils literal"><span class="pre">combtest.runner.WalkExecutorService</span></code></a></p>
<p>A <code class="docutils literal"><span class="pre">WalkExecutorService</span></code> for executing <code class="docutils literal"><span class="pre">Walks</span></code> in multiple stages. That
is: we can execute <code class="docutils literal"><span class="pre">Walks</span></code> in parts/slices. A <code class="docutils literal"><span class="pre">walk_id</span></code> is used to
refer to the <code class="docutils literal"><span class="pre">Walks</span></code> uniquely.</p>
<dl class="attribute">
<dt id="combtest.runner.MultistageWalkRunningService.RUNNER_TYPE">
<code class="descname">RUNNER_TYPE</code><a class="headerlink" href="#combtest.runner.MultistageWalkRunningService.RUNNER_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#combtest.runner.MultistageWalkRunner" title="combtest.runner.MultistageWalkRunner"><code class="xref py py-class docutils literal"><span class="pre">MultistageWalkRunner</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.runner.WalkExecutorService">
<em class="property">class </em><code class="descclassname">combtest.runner.</code><code class="descname">WalkExecutorService</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkExecutorService"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkExecutorService" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><code class="xref py py-class docutils literal"><span class="pre">combtest.worker.CoordinatorService</span></code></a></p>
<p>Simplest rpyc-based services for running walks across the cluster: the user
only needs to provide a list of <code class="docutils literal"><span class="pre">Walks</span></code> to their corresponding ServiceGroup.
The rest is handled.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>The user should probably not be calling into this directly. They
should be starting it up via rpyc.</dd>
</dl>
<dl class="attribute">
<dt id="combtest.runner.WalkExecutorService.WALK_RUNNER_TYPE">
<code class="descname">WALK_RUNNER_TYPE</code><a class="headerlink" href="#combtest.runner.WalkExecutorService.WALK_RUNNER_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the type of <code class="docutils literal"><span class="pre">WalkRunner</span></code> used, here or in a child class</p>
<p>alias of <a class="reference internal" href="#combtest.runner.WalkRunner" title="combtest.runner.WalkRunner"><code class="xref py py-class docutils literal"><span class="pre">WalkRunner</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.runner.WalkExecutorService.WORKER_TYPE">
<code class="descname">WORKER_TYPE</code><a class="headerlink" href="#combtest.runner.WalkExecutorService.WORKER_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the type of <code class="docutils literal"><span class="pre">ThreadPool</span></code> used for executing <code class="docutils literal"><span class="pre">Walks</span></code>, here
or in a child class</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">WalkThreadPool</span></code></p>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.WalkExecutorService.work_repack">
<code class="descname">work_repack</code><span class="sig-paren">(</span><em>work</em>, <em>ctx=None</em>, <em>resp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkExecutorService.work_repack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkExecutorService.work_repack" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called back to repackage each work item sent to the service.
The call is an opportunity to e.g. do some deserialization, wrap the
<code class="docutils literal"><span class="pre">Walk</span></code> in a <code class="docutils literal"><span class="pre">WalkRunner</span></code>, or anything else the user needs to prep
the work for execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>work</strong> (<em>object</em>) &#8211; the work to execute; typically this will be e.g. a
JSONified <code class="docutils literal"><span class="pre">Walk</span></code>.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; a <code class="docutils literal"><span class="pre">ctx</span></code> copied in for executing the <code class="docutils literal"><span class="pre">Walk</span></code></li>
<li><strong>resp</strong> (<em>dict</em>) &#8211; a dict to which response objects can be attached by
the <code class="docutils literal"><span class="pre">Walk</span></code> for retrieval later.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.runner.WalkRunner">
<em class="property">class </em><code class="descclassname">combtest.runner.</code><code class="descname">WalkRunner</code><span class="sig-paren">(</span><em>resp_object</em>, <em>reporting_interval=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A WalkRunner simply wraps a <code class="docutils literal"><span class="pre">Walks</span></code> execution method with some tracking
for reporting stats. The user is free to inherit and add more stats as they
see fit.</p>
<dl class="method">
<dt id="combtest.runner.WalkRunner.count_cancel">
<code class="descname">count_cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner.count_cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner.count_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a <code class="docutils literal"><span class="pre">Walk</span></code> is canceled.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.WalkRunner.count_error">
<code class="descname">count_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner.count_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner.count_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Called on a <code class="docutils literal"><span class="pre">Walk</span></code> execution error.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.WalkRunner.count_total">
<code class="descname">count_total</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner.count_total"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner.count_total" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to count the number of <code class="docutils literal"><span class="pre">Walks</span></code>/Walk segments we started
running.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.WalkRunner.prep_work_call">
<code class="descname">prep_work_call</code><span class="sig-paren">(</span><em>walk_to_run</em>, <em>walk_ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner.prep_work_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner.prep_work_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to wrap a <code class="docutils literal"><span class="pre">Walk</span></code> into a callable that accepts a single
argument: the <code class="docutils literal"><span class="pre">ctx</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.runner.WalkRunner.run_walk">
<code class="descname">run_walk</code><span class="sig-paren">(</span><em>walk_to_run</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#WalkRunner.run_walk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.WalkRunner.run_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to run an individual <code class="docutils literal"><span class="pre">Walk</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="combtest.runner.replay_multistage_walk">
<code class="descclassname">combtest.runner.</code><code class="descname">replay_multistage_walk</code><span class="sig-paren">(</span><em>walk_to_run</em>, <em>step=False</em>, <em>log_errors=True</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#replay_multistage_walk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.replay_multistage_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a single <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>walk_to_run</strong> (<a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><em>Walk</em></a>) &#8211; self evident</li>
<li><strong>step</strong> (<em>bool</em>) &#8211; if True, step Action-by-Action through the Walk; the user
hits a key to proceed to the next Action.</li>
<li><strong>log_errors</strong> (<em>bool</em>) &#8211; log exceptions to the logger if True</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; state/<code class="docutils literal"><span class="pre">ctx</span></code> passed to the Walk for execution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.runner.run_multistage_walks">
<code class="descclassname">combtest.runner.</code><code class="descname">run_multistage_walks</code><span class="sig-paren">(</span><em>walk_order</em>, <em>ctx=None</em>, <em>verbose=False</em>, <em>logger_port=None</em>, <em>runner_class=&lt;class 'combtest.runner.MultistageWalkRunningService'&gt;</em>, <em>service_group_class=&lt;class 'combtest.runner.ContinuingWalkServiceGroup'&gt;</em>, <em>service_infos=None</em>, <em>service_handler_class=&lt;class 'combtest.bootstrap.ServiceHandler_Local'&gt;</em>, <em>max_thread_count=None</em>, <em>gather_ctxs=False</em>, <em>log_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#run_multistage_walks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.run_multistage_walks" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a collection of <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>. This should be the main
way to execute <code class="docutils literal"><span class="pre">Walks</span></code> for most users. This is the only interface that
supports correct execution of a <a class="reference internal" href="#combtest.action.SyncPoint" title="combtest.action.SyncPoint"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.SyncPoint</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>walk_order</strong> (<em>iterable</em>) &#8211; An iterable of iterables which produce
<a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a>. Example: a
list of iterables produced by
<code class="docutils literal"><span class="pre">MyActionClass.get_option_set()</span></code>.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; a state/<code class="docutils literal"><span class="pre">ctx</span></code> to pass to copy and pass to the
<code class="docutils literal"><span class="pre">Walks</span></code> when we execute them.</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; produce a verbose level log, and set the log level to
DEBUG.</li>
<li><strong>logger_port</strong> (<em>int</em>) &#8211; the port number where our local logger should
accept data.</li>
<li><strong>runner_class</strong> (<a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><em>combtest.worker.CoordinatorService</em></a>) &#8211; the type of Walk
execution service
to use.</li>
<li><strong>service_group_class</strong> (<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><em>combtest.worker.ServiceGroup</em></a>) &#8211; the type of
<code class="docutils literal"><span class="pre">ServiceGroup</span></code>
we will use to
coordinate remote
executors</li>
<li><strong>service_infos</strong> (<em>iterable</em>) &#8211; An iterable of any extra infos we need to
bootstrap the remote services. See
<a class="reference internal" href="#combtest.bootstrap.ServiceHandleArray" title="combtest.bootstrap.ServiceHandleArray"><code class="xref py py-class docutils literal"><span class="pre">combtest.bootstrap.ServiceHandleArray</span></code></a>.</li>
<li><strong>service_handler_class</strong> (<a class="reference internal" href="#combtest.bootstrap.ServiceHandler" title="combtest.bootstrap.ServiceHandler"><em>combtest.bootstrap.ServiceHandler</em></a>) &#8211; Type of
<code class="docutils literal"><span class="pre">ServiceHandler</span></code> to use to bootstrap the services.</li>
<li><strong>gather_ctxs</strong> (<em>bool</em>) &#8211; if True, gather and return all <code class="docutils literal"><span class="pre">ctxs</span></code> from the
remote services at the end of the run. Will be
returned as a mapping ip-&gt;[ctx, ...]</li>
<li><strong>max_thread_count</strong> (<em>int</em>) &#8211; Max number of <code class="docutils literal"><span class="pre">Walk</span></code> executing threads that
each service will use.</li>
<li><strong>log_dir</strong> (<em>str</em>) &#8211; Directory where we will store traces, debug logs, etc.
Remote services will also attempt to store logs to
the same path.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> &#8211; when remote services can&#8217;t be established and
connected to.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">count of walks run, count of walk execution errors, count of walk
segments run, total elapsed time, remote ctxs if
<code class="docutils literal"><span class="pre">gather_ctxs</span> <span class="pre">==</span> <span class="pre">True</span></code> else None, the location of the master
log file, where applicable.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.runner.run_walks">
<code class="descclassname">combtest.runner.</code><code class="descname">run_walks</code><span class="sig-paren">(</span><em>walk_options</em>, <em>ctx=None</em>, <em>verbose=False</em>, <em>logger_port=None</em>, <em>runner_class=&lt;class 'combtest.runner.WalkExecutorService'&gt;</em>, <em>service_group_class=&lt;class 'combtest.worker.ServiceGroup'&gt;</em>, <em>service_infos=None</em>, <em>service_handler_class=&lt;class 'combtest.bootstrap.ServiceHandler_Local'&gt;</em>, <em>gather_ctxs=False</em>, <em>max_thread_count=None</em>, <em>**runner_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/runner.html#run_walks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.runner.run_walks" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a collection of <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>. This is one of the main
functions that the user should probably be using to run their tests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>walk_options</strong> (<em>iterable</em>) &#8211; An iterable of iterables which produce
<a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a>. Example: a
list of iterables produced by
<code class="docutils literal"><span class="pre">MyActionClass.get_option_set()</span></code>.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; a state/<code class="docutils literal"><span class="pre">ctx</span></code> to pass to copy and pass to the
<code class="docutils literal"><span class="pre">Walks</span></code> when we execute them.</li>
<li><strong>verbose</strong> (<em>bool</em>) &#8211; produce a verbose level log, and set the log level to
DEBUG.</li>
<li><strong>logger_port</strong> (<em>int</em>) &#8211; the port number where our local logger should
accept data.</li>
<li><strong>runner_class</strong> (<a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><em>combtest.worker.CoordinatorService</em></a>) &#8211; the type of Walk
execution service
to use.</li>
<li><strong>service_group_class</strong> (<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><em>combtest.worker.ServiceGroup</em></a>) &#8211; the type of
<code class="docutils literal"><span class="pre">ServiceGroup</span></code>
we will use to
coordinate remote
executors</li>
<li><strong>service_infos</strong> (<em>iterable</em>) &#8211; An iterable of any extra infos we need to
bootstrap the remote services. See
<a class="reference internal" href="#combtest.bootstrap.ServiceHandleArray" title="combtest.bootstrap.ServiceHandleArray"><code class="xref py py-class docutils literal"><span class="pre">combtest.bootstrap.ServiceHandleArray</span></code></a>.</li>
<li><strong>service_handler_class</strong> (<a class="reference internal" href="#combtest.bootstrap.ServiceHandler" title="combtest.bootstrap.ServiceHandler"><em>combtest.bootstrap.ServiceHandler</em></a>) &#8211; Type of
<code class="docutils literal"><span class="pre">ServiceHandler</span></code> to use to bootstrap the services.</li>
<li><strong>gather_ctxs</strong> (<em>bool</em>) &#8211; if True, gather and return all <code class="docutils literal"><span class="pre">ctxs</span></code> from the
remote services at the end of the run. Will be
returned as a mapping ip-&gt;[ctx, ...]</li>
<li><strong>max_thread_count</strong> (<em>int</em>) &#8211; Max number of <code class="docutils literal"><span class="pre">Walk</span></code> executing threads that
each service will use.</li>
<li><strong>runner_kwargs</strong> &#8211; kwargs to pass to the remote <code class="docutils literal"><span class="pre">WalkRunner</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> &#8211; when remote services can&#8217;t be established and
connected to.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">count of walks run, count of walk execution errors, total elapsed
time, remote ctxs if <code class="docutils literal"><span class="pre">gather_ctxs</span> <span class="pre">==</span> <span class="pre">True</span></code>, else None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-combtest.ssh_handle">
<span id="ssh-handle-module"></span><h2>ssh_handle module<a class="headerlink" href="#module-combtest.ssh_handle" title="Permalink to this headline">¶</a></h2>
<p>SSH-based connection for bootstrapping remote rpyc services. The user does not
have to use this, but it is provided as a default implementation for those not
wanting to write their own connection logic.</p>
<dl class="class">
<dt id="combtest.ssh_handle.ServiceHandler_SSH">
<em class="property">class </em><code class="descclassname">combtest.ssh_handle.</code><code class="descname">ServiceHandler_SSH</code><span class="sig-paren">(</span><em>connection_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/ssh_handle.html#ServiceHandler_SSH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.ssh_handle.ServiceHandler_SSH" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide an SSH-based method of bootstrapping our rpyc <code class="docutils literal"><span class="pre">Walk</span></code> executors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>connection_info</strong> (<a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><em>ConnectionInfo</em></a>) &#8211; a <a class="reference internal" href="#combtest.bootstrap.ConnectionInfo" title="combtest.bootstrap.ConnectionInfo"><code class="xref py py-class docutils literal"><span class="pre">combtest.bootstrap.ConnectionInfo</span></code></a>
which optionally provides a
<code class="docutils literal"><span class="pre">service_info</span></code> dictionary
containing SSH authentication
info. You can get such a dict from
<a class="reference internal" href="#combtest.config.get_ssh_options" title="combtest.config.get_ssh_options"><code class="xref py py-func docutils literal"><span class="pre">combtest.config.get_ssh_options()</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-combtest.utils">
<span id="utils-module"></span><h2>utils module<a class="headerlink" href="#module-combtest.utils" title="Permalink to this headline">¶</a></h2>
<p>Misc utils</p>
<dl class="class">
<dt id="combtest.utils.RangeTree">
<em class="property">class </em><code class="descclassname">combtest.utils.</code><code class="descname">RangeTree</code><span class="sig-paren">(</span><em>min_idx</em>, <em>max_idx</em>, <em>root_value=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/utils.html#RangeTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.utils.RangeTree" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of a range, with the levels of the tree representing
hierarchical splits of the range.
O(N) mem in the number of sub-ranges.
Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">--&gt;</span><span class="mi">972</span>
  <span class="o">--&gt;</span><span class="mi">486</span>
    <span class="o">--&gt;</span><span class="mi">243</span>
    <span class="o">--&gt;</span><span class="mi">243</span>
  <span class="o">--&gt;</span><span class="mi">486</span>
    <span class="o">--&gt;</span><span class="mi">243</span>
    <span class="o">--&gt;</span><span class="mi">243</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="combtest.utils.get_class_from_qualname">
<code class="descclassname">combtest.utils.</code><code class="descname">get_class_from_qualname</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/utils.html#get_class_from_qualname"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.utils.get_class_from_qualname" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a fully qualified class name to a class, attempting any imports
that need to be done along the way.
:raises: ImportError or AttributeError if we can&#8217;t figure out how to import it</p>
</dd></dl>

<dl class="function">
<dt id="combtest.utils.get_class_qualname">
<code class="descclassname">combtest.utils.</code><code class="descname">get_class_qualname</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/utils.html#get_class_qualname"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.utils.get_class_qualname" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a fully qualified name for a class (and therefore a function ref as
well). Example: &#8216;combtest.action.Action&#8217;.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Python3 has this, or something like it, called <code class="docutils literal"><span class="pre">__qualname__</span></code>. We
implement our own here to retain control of it, and give us Python2
compat.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="combtest.utils.get_my_IP">
<code class="descclassname">combtest.utils.</code><code class="descname">get_my_IP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/utils.html#get_my_IP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.utils.get_my_IP" title="Permalink to this definition">¶</a></dt>
<dd><p>Get our best guess at one of our local IPs that others could use to contact
us (e.g. to connect to a local log server).</p>
</dd></dl>

<dl class="function">
<dt id="combtest.utils.set_my_IP">
<code class="descclassname">combtest.utils.</code><code class="descname">set_my_IP</code><span class="sig-paren">(</span><em>ip</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/utils.html#set_my_IP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.utils.set_my_IP" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the IP that the rest of the system should assume is our local IP
address. This may work for a hostname as well, but that isn&#8217;t well tested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ip</strong> (<em>str</em>) &#8211; ip as a string</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-combtest.walk">
<span id="walk-module"></span><h2>walk module<a class="headerlink" href="#module-combtest.walk" title="Permalink to this headline">¶</a></h2>
<p>This module provides ways of systematically combining operations, sets of
operations, etc., and executing such sequences of operations.</p>
<dl class="exception">
<dt id="combtest.walk.CancelWalk">
<em class="property">exception </em><code class="descclassname">combtest.walk.</code><code class="descname">CancelWalk</code><a class="reference internal" href="_modules/combtest/walk.html#CancelWalk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.CancelWalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised to immediately stop the execution of a <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="combtest.walk.Walk">
<em class="property">class </em><code class="descclassname">combtest.walk.</code><code class="descname">Walk</code><span class="sig-paren">(</span><em>*elems</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/walk.html#Walk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.Walk" title="Permalink to this definition">¶</a></dt>
<dd><p>A Walk, named after the graph theory concept, is a list of
<a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a> to execute, together with a piece of
state that the Actions can manipulate. The notion here is that each
<code class="docutils literal"><span class="pre">Action</span></code> performs an operation that takes us through a transition
in state/action space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elems</strong> (<em>iterable</em>) &#8211; An iterable of <a class="reference internal" href="#combtest.action.Action" title="combtest.action.Action"><code class="xref py py-class docutils literal"><span class="pre">combtest.action.Action</span></code></a></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="combtest.walk.Walk.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/walk.html#Walk.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.Walk.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically equivalent to list.append</p>
</dd></dl>

<dl class="method">
<dt id="combtest.walk.Walk.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>dynamic_ctx</em>, <em>log_errors=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/walk.html#Walk.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.Walk.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the <code class="docutils literal"><span class="pre">Actions</span></code> in order. If an Action raises
<a class="reference internal" href="#combtest.walk.CancelWalk" title="combtest.walk.CancelWalk"><code class="xref py py-class docutils literal"><span class="pre">CancelWalk</span></code></a>, we will stop executing immediately.
:return: True if the Walk was run successfully or <cite>CancelWalk</cite> was raised, False otherwise.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="combtest.walk.WalkFailedError">
<em class="property">exception </em><code class="descclassname">combtest.walk.</code><code class="descname">WalkFailedError</code><a class="reference internal" href="_modules/combtest/walk.html#WalkFailedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.WalkFailedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when a <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">combtest.walk.Walk</span></code></a> failed to execute to completion
for any reason (e.g. one of its operations raised an <code class="docutils literal"><span class="pre">Exception</span></code>).</p>
</dd></dl>

<dl class="class">
<dt id="combtest.walk.WalkOpTracer">
<em class="property">class </em><code class="descclassname">combtest.walk.</code><code class="descname">WalkOpTracer</code><span class="sig-paren">(</span><em>log_dir</em>, <em>*namespace</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/walk.html#WalkOpTracer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.WalkOpTracer" title="Permalink to this definition">¶</a></dt>
<dd><p>Traces a <a class="reference internal" href="#combtest.walk.Walk" title="combtest.walk.Walk"><code class="xref py py-class docutils literal"><span class="pre">Walk</span></code></a> portion + its adjacent <code class="xref py py-class docutils literal"><span class="pre">SyncPoint</span></code> and
<code class="docutils literal"><span class="pre">walk_id</span></code>. The id is consistent across portions so that you can relate
them back together later.</p>
</dd></dl>

<dl class="class">
<dt id="combtest.walk.WalkOptions">
<em class="property">class </em><code class="descclassname">combtest.walk.</code><code class="descname">WalkOptions</code><span class="sig-paren">(</span><em>walk_order</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/walk.html#WalkOptions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.walk.WalkOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>A WalkOptions accepts a set of <code class="xref py py-class docutils literal"><span class="pre">Action</span></code> and <code class="xref py py-class docutils literal"><span class="pre">SyncPoint</span></code>
options and produces an iterable of <code class="xref py py-class docutils literal"><span class="pre">Epoch</span></code>. Each <cite>Epoch</cite> represents
a set of <code class="docutils literal"><span class="pre">Walk</span></code> segments which can run in parallel, and an optional
<code class="docutils literal"><span class="pre">SyncPoint</span></code> which should be run <em>before</em> the <code class="docutils literal"><span class="pre">Walk</span></code> portions.</p>
<p>Not threadsafe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>walk_order</strong> (<em>iterable</em>) &#8211; An iterable <code class="xref py py-class docutils literal"><span class="pre">Action</span></code> types</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="combtest.walk.WalkOptions.sizes">
<code class="descname">sizes</code><a class="headerlink" href="#combtest.walk.WalkOptions.sizes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A tuple of the size of the option sets for each
<code class="xref py py-class docutils literal"><span class="pre">Action</span></code> type in this <code class="docutils literal"><span class="pre">WalkOptions</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-combtest.worker">
<span id="worker-module"></span><h2>worker module<a class="headerlink" href="#module-combtest.worker" title="Permalink to this headline">¶</a></h2>
<p>This module provides a set of mechanisms for dispatching &#8220;work&#8221; across a
set of worker nodes. &#8220;Work&#8221; can mean &#8220;execute sets of arbitrary Python
code&#8221;. This system is made of a few pieces:</p>
<ul class="simple">
<li>A basic thread pool implementation. There is a <code class="xref py py-class docutils literal"><span class="pre">multiprocessing.ThreadPool</span></code>
implementation in Python already,
but I want the control and flexibility of having my own. This and its
decendents are the &#8220;workers&#8221; that actually e.g. execute test cases or
run fuzz+stress load (see <a class="reference internal" href="#combtest.worker.ThreadPool" title="combtest.worker.ThreadPool"><code class="xref py py-class docutils literal"><span class="pre">ThreadPool</span></code></a>). Thread
counts can be chosen by the client, by default, whatever.</li>
<li>An rpyc-based coordinator that deserializes work sent to it and sends it
to a worker/executor of some sort, which will typically be a ThreadPool
(see <a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><code class="xref py py-class docutils literal"><span class="pre">CoordinatorService</span></code></a> below). Typically there will be one of
these per node running in its own process, or at least one of a given
&#8220;type&#8221; per node. The only constraint is that it needs to have a 1:1 ip/port
mapping. Typically there will be one central coordinator
(<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">ServiceGroup</span></code></a>) paired with one <code class="docutils literal"><span class="pre">CoordinatorService</span></code> per node.</li>
<li>A central coordinator running in a single process that is passed work and
sends it to all paired remote coordinators for execution
(<a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">ServiceGroup</span></code></a>).</li>
</ul>
<p>Work is sent in some quantum defined by the client code and passed from
<code class="docutils literal"><span class="pre">ServiceGroup-&gt;CoordinatorService-&gt;ThreadPool</span></code>. Responses can be sent back.</p>
<ul class="simple">
<li>The quantum should be large enough for a worker to keep its children busy</li>
<li>The child may quit before all work is done if e.g. a failure limit is
reached, or a fatal error hit.</li>
<li>A parent can specify how many workers a child can have, otherwise a worker
is free to decide.</li>
<li>A parent can raise signal or other condition to a child to tell it to quit
early. It must obey and send back any accumulated responses, or have its
results abandoned.</li>
<li>Parent must deal with errors where the child dies silently (e.g.
interpreter crash hard enough that we don&#8217;t run atexit handlers)</li>
</ul>
<dl class="class">
<dt id="combtest.worker.CoordinatorService">
<em class="property">class </em><code class="descclassname">combtest.worker.</code><code class="descname">CoordinatorService</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rpyc.core.service.Service</span></code></p>
<p>Receives work from a remote process via rpyc, starts the work running via
<a class="reference internal" href="#combtest.worker.ThreadPool" title="combtest.worker.ThreadPool"><code class="xref py py-class docutils literal"><span class="pre">ThreadPool</span></code></a> or some decendent class.</p>
<dl class="attribute">
<dt id="combtest.worker.CoordinatorService.DEFAULT_MAX_THREAD_COUNT">
<code class="descname">DEFAULT_MAX_THREAD_COUNT</code><em class="property"> = 72</em><a class="headerlink" href="#combtest.worker.CoordinatorService.DEFAULT_MAX_THREAD_COUNT" title="Permalink to this definition">¶</a></dt>
<dd><p>Override point for max number of threads for each worker to have. The
other ways to set this are 1. via config.py, and 2. via an option passed
at runtime (e.g. via <a class="reference internal" href="#combtest.worker.CoordinatorService.exposed_start_workers_on" title="combtest.worker.CoordinatorService.exposed_start_workers_on"><code class="xref py py-func docutils literal"><span class="pre">exposed_start_workers_on()</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.worker.CoordinatorService.WORKER_TYPE">
<code class="descname">WORKER_TYPE</code><a class="headerlink" href="#combtest.worker.CoordinatorService.WORKER_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>a ThreadPool class that workers should be instantiated from
User can override</p>
<p>alias of <a class="reference internal" href="#combtest.worker.ThreadPool" title="combtest.worker.ThreadPool"><code class="xref py py-class docutils literal"><span class="pre">ThreadPool</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_add_work">
<code class="descname">exposed_add_work</code><span class="sig-paren">(</span><em>worker_id</em>, <em>work</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_add_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_add_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Add work to an existing worker. The original ctx will be used.
If the user wants work to be executed with a different ctx,
they start a new worker up via <a class="reference internal" href="#combtest.worker.CoordinatorService.exposed_start_work" title="combtest.worker.CoordinatorService.exposed_start_work"><code class="xref py py-func docutils literal"><span class="pre">exposed_start_work()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>worker_id</strong> (<em>int</em>) &#8211; the <code class="docutils literal"><span class="pre">worker_id</span></code> returned from the func used to
start work</li>
<li><strong>work</strong> (<em>object</em>) &#8211; the work item</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_clean_worker">
<code class="descname">exposed_clean_worker</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_clean_worker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_clean_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>Toss all state related to a worker. Implies a join first.
Gives the user full control over when we reap memory, since they may
still want to retrieve/pickle results. It isn&#8217;t enough to wait until
after they gather the response, since a.) they may not have &#8220;obtained&#8221;
the response value yet, and b.) they may just be gathering intermediate
results.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_gather_ctx">
<code class="descname">exposed_gather_ctx</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_gather_ctx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_gather_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ctx associated with the given worker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_id</strong> (<em>int</em>) &#8211; the <code class="docutils literal"><span class="pre">worker_id</span></code> returned from the func used to
start work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_gather_resp">
<code class="descname">exposed_gather_resp</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_gather_resp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_gather_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resp object associated with the given worker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_id</strong> (<em>int</em>) &#8211; the <code class="docutils literal"><span class="pre">worker_id</span></code> returned from the func used to
start work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_join_all_workers">
<code class="descname">exposed_join_all_workers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_join_all_workers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_join_all_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Like join_workers, but tosses all outstanding workers.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_join_workers">
<code class="descname">exposed_join_workers</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_join_workers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_join_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>Join all working threads in a worker and toss the worker for further
use. The responses and ctxs will stay around until the client &#8220;cleans&#8221;
the worker state. That means this is <em>not</em> a stateless service. The
user needs to beware of leaking resources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_id</strong> (<em>int</em>) &#8211; the <code class="docutils literal"><span class="pre">worker_id</span></code> returned from the func used to
start work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_run">
<code class="descname">exposed_run</code><span class="sig-paren">(</span><em>work</em>, <em>max_thread_count=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run work synchronously. Return a <code class="docutils literal"><span class="pre">worker_id</span></code> so that responses/ctxs
can be reclaimed.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_signal_stop">
<code class="descname">exposed_signal_stop</code><span class="sig-paren">(</span><em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_signal_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_signal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal that a worker should stop. May not be immediate since this is
intended to be a &#8220;clean&#8221; shutdown where workers can finish their
current work item.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_id</strong> (<em>int</em>) &#8211; the <code class="docutils literal"><span class="pre">worker_id</span></code> returned from the func used to
start work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_start_remote_logging">
<code class="descname">exposed_start_remote_logging</code><span class="sig-paren">(</span><em>ip</em>, <em>port</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_start_remote_logging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_start_remote_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Start sending logs to the log server at the given ip+port.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ip</strong> (<em>str</em>) &#8211; hostname or ip where the log server is running</li>
<li><strong>port</strong> (<em>int</em>) &#8211; port number where the log server is running</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_start_work">
<code class="descname">exposed_start_work</code><span class="sig-paren">(</span><em>work</em>, <em>max_thread_count=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_start_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_start_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by remote side to start some work running asynchronously. The
work and ctx are pickled and pulled through to this side in whole,
rather than accessing via netrefs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a worker_id to refer back to this work later for e.g. stopping
it or getting responses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.exposed_start_workers_on">
<code class="descname">exposed_start_workers_on</code><span class="sig-paren">(</span><em>work</em>, <em>max_thread_count=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.exposed_start_workers_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.exposed_start_workers_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to start_work, but a single item is sent, and all threads in
the new worker will run that single item.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The <code class="docutils literal"><span class="pre">worker_id</span></code> of the worker executing the work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.on_connect">
<code class="descname">on_connect</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.on_connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.on_connect" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">rpyc.Service</span></code> is designed for this to be the de-facto
<code class="docutils literal"><span class="pre">__init__</span></code> function.  So we are doing our initialization here.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.CoordinatorService.work_repack">
<code class="descname">work_repack</code><span class="sig-paren">(</span><em>work</em>, <em>ctx=None</em>, <em>resp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#CoordinatorService.work_repack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.CoordinatorService.work_repack" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called back to repackage each work item sent to the service.
The call is an opportunity to e.g. do some deserialization, wrap the
<code class="docutils literal"><span class="pre">Walk</span></code> in a <code class="docutils literal"><span class="pre">WalkRunner</span></code>, or anything else the user needs to prep
the work for execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>work</strong> (<em>object</em>) &#8211; the work to execute; typically this will be e.g. a
JSONified <code class="docutils literal"><span class="pre">Walk</span></code>.</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; a <code class="docutils literal"><span class="pre">ctx</span></code> copied in for executing the <code class="docutils literal"><span class="pre">Walk</span></code></li>
<li><strong>resp</strong> (<em>dict</em>) &#8211; a dict to which response objects can be attached by
the <code class="docutils literal"><span class="pre">Walk</span></code> for retrieval later.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.worker.ServiceGroup">
<em class="property">class </em><code class="descclassname">combtest.worker.</code><code class="descname">ServiceGroup</code><span class="sig-paren">(</span><em>service_name</em>, <em>service_infos=None</em>, <em>service_handler_class=&lt;class 'combtest.bootstrap.ServiceHandler_Local'&gt;</em>, <em>spawn_services=True</em>, <em>spawn_clients=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Handles to running service instances across the nodes via e.g. SSH, and
rpyc-based clients connected to those. This has a number of functions for
dispatching work to the execution services, and gathering responses and
stats.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We spawn connections to all nodes. b/w the SSH connections and
client connections we may run into scalability issues on giant
clusters. There are obvious optimizations we can do here,
such as lazy connecting, but it would require some extra
hooks. Please file a bug later when/if we prove there is
such a problem and a need for a fix.</p>
</div>
<dl class="attribute">
<dt id="combtest.worker.ServiceGroup.DEFAULT_INSTANCE_COUNT">
<code class="descname">DEFAULT_INSTANCE_COUNT</code><em class="property"> = 3</em><a class="headerlink" href="#combtest.worker.ServiceGroup.DEFAULT_INSTANCE_COUNT" title="Permalink to this definition">¶</a></dt>
<dd><p>If the user does not provide a specific enumeration of ip/port where we
should set services up running, this will be the default number of
services to start up, which we will start locally.</p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.worker.ServiceGroup.SPAWN_TIMEOUT">
<code class="descname">SPAWN_TIMEOUT</code><em class="property"> = 30</em><a class="headerlink" href="#combtest.worker.ServiceGroup.SPAWN_TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Max time we spend waiting for a service spawn to succeed. We use this
since e.g. starting services does not mean the service is immediately
available, due to waiting for imports to happen. Hence the clients
need to retry for a bit until the services come up. This timeout is
measured in seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.worker.ServiceGroup.WORK_QUANTUM_SIZE">
<code class="descname">WORK_QUANTUM_SIZE</code><em class="property"> = 1000</em><a class="headerlink" href="#combtest.worker.ServiceGroup.WORK_QUANTUM_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum chunk of work we will send in a single RPC call. This is to
keep the request size sane. If the user gives us an iterable that is
generating a massive amount of work on-the-fly we may not be able to
instantiate it all and hold it in memory. So we send batches that are
this size at maximum.</p>
</dd></dl>

<dl class="attribute">
<dt id="combtest.worker.ServiceGroup.clients">
<code class="descname">clients</code><a class="headerlink" href="#combtest.worker.ServiceGroup.clients" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mapping (ip, port)-&gt;client &#8220;root&#8221; (see rpyc connect docs)</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.gather_all_ctxs">
<code class="descname">gather_all_ctxs</code><span class="sig-paren">(</span><em>worker_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.gather_all_ctxs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.gather_all_ctxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather ctxs from all the given workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_ids</strong> (<em>dict</em>) &#8211; a mapping (hostname/ip, port)-&gt;worker_id</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of ctxs in no particular order.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.gather_all_resp">
<code class="descname">gather_all_resp</code><span class="sig-paren">(</span><em>worker_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.gather_all_resp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.gather_all_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather resp from all the given workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>worker_ids</strong> (<em>dict</em>) &#8211; a mapping (hostname/ip, port)-&gt;worker_id</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of respones in no particular order.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.gather_ctx">
<code class="descname">gather_ctx</code><span class="sig-paren">(</span><em>connection</em>, <em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.gather_ctx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.gather_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather <code class="docutils literal"><span class="pre">ctx</span></code> from a remote service for a given worker. A running
<code class="xref py py-class docutils literal"><span class="pre">Walk</span></code> is free to mutate its <code class="docutils literal"><span class="pre">ctx</span></code>, and sometimes that is what
really constitutes the &#8220;response&#8221; or &#8220;output&#8221; of a quantum of work.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> (<em>tuple</em>) &#8211; str hostname/ip of the remote service, int
port number</li>
<li><strong>worker_id</strong> (<em>int</em>) &#8211; id of remote worker, as returned when starting
the work (see <a class="reference internal" href="#combtest.worker.ServiceGroup.scatter_work" title="combtest.worker.ServiceGroup.scatter_work"><code class="xref py py-func docutils literal"><span class="pre">scatter_work()</span></code></a>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.gather_resp">
<code class="descname">gather_resp</code><span class="sig-paren">(</span><em>connection</em>, <em>worker_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.gather_resp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.gather_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather responses from all the given workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>connection</strong> (<em>tuple</em>) &#8211; str hostname/ip of the remote service, int
port number</li>
<li><strong>worker_id</strong> (<em>int</em>) &#8211; id of remote worker, as returned when starting
the work (see <a class="reference internal" href="#combtest.worker.ServiceGroup.scatter_work" title="combtest.worker.ServiceGroup.scatter_work"><code class="xref py py-func docutils literal"><span class="pre">scatter_work()</span></code></a>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a response object, as passed to the <code class="docutils literal"><span class="pre">Walk</span></code> that ran on the
remote side. See
<a class="reference internal" href="#combtest.worker.CoordinatorService.exposed_start_workers_on" title="combtest.worker.CoordinatorService.exposed_start_workers_on"><code class="xref py py-func docutils literal"><span class="pre">CoordinatorService.exposed_start_workers_on()</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="combtest.worker.ServiceGroup.give_up">
<em class="property">classmethod </em><code class="descname">give_up</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.give_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.give_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal that all <a class="reference internal" href="#combtest.worker.ServiceGroup" title="combtest.worker.ServiceGroup"><code class="xref py py-class docutils literal"><span class="pre">ServiceGroup</span></code></a> should give up trying to connect
to remote services, send work, etc. and bail immediately. We can use
this e.g. if we receive a signal locally and don&#8217;t want to wait for a
long-running scatter or gather.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>hard=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for all workers on all remote services to complete.
We can have a finer-grained function later if it is helpful.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hard</strong> (<em>bool</em>) &#8211; ignore errors if True</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>EOFError, ReferenceError, RuntimeError</strong> &#8211; if we have an issue
while joinging (e.g.
the remote side died)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>work</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatter work to all remote services, wait for it to finish executing,
then return gathered responses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work</strong> (<em>iterable</em>) &#8211; iterable of work items</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; make sure it is picklable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of responses, whose ordering is not particularly
important.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.scatter_work">
<code class="descname">scatter_work</code><span class="sig-paren">(</span><em>work</em>, <em>max_thread_count=None</em>, <em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.scatter_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.scatter_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the provided iterable of work into roughly even-sized
portions and send them to each of the remote services. <code class="docutils literal"><span class="pre">ctx</span></code> will be
copied to each node independently. The user must handle the logic of
retrieving results and stitching them together. See <a class="reference internal" href="#combtest.worker.ServiceGroup.gather_ctx" title="combtest.worker.ServiceGroup.gather_ctx"><code class="xref py py-func docutils literal"><span class="pre">gather_ctx()</span></code></a>,
<a class="reference internal" href="#combtest.worker.ServiceGroup.gather_resp" title="combtest.worker.ServiceGroup.gather_resp"><code class="xref py py-func docutils literal"><span class="pre">gather_resp()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work</strong> (<em>iterable</em>) &#8211; iterable of work items</li>
<li><strong>max_thread_count</strong> (<em>int</em>) &#8211; override of how many threads each remote
executor should have</li>
<li><strong>ctx</strong> (<em>object</em>) &#8211; make sure it is picklable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict mapping (hostname/ip, port) -&gt; worker_id</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><em>hard=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.shutdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down both clients and services.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hard</strong> (<em>bool</em>) &#8211; if hard, we will ignore any errors trying to shut
down</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.shutdown_clients">
<code class="descname">shutdown_clients</code><span class="sig-paren">(</span><em>hard=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.shutdown_clients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.shutdown_clients" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down all running clients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hard</strong> (<em>bool</em>) &#8211; if hard, we will ignore any errors trying to shut
down</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.shutdown_services">
<code class="descname">shutdown_services</code><span class="sig-paren">(</span><em>hard=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.shutdown_services"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.shutdown_services" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down all running services.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hard</strong> (<em>bool</em>) &#8211; if hard, we will ignore any errors trying to shut
down</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.spawn">
<code class="descname">spawn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.spawn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.spawn" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn both services and clients (in that order).</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.spawn_clients">
<code class="descname">spawn_clients</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.spawn_clients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.spawn_clients" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn rpyc clients to the remote services. Assumes remote services are
up, or will be within <code class="docutils literal"><span class="pre">SPAWN_TIMEOUT</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.spawn_services">
<code class="descname">spawn_services</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.spawn_services"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.spawn_services" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn remote services via some bootstrap method.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.start_all_on">
<code class="descname">start_all_on</code><span class="sig-paren">(</span><em>work_item</em>, <em>shared_ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.start_all_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.start_all_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a single item of work running on all remote services.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>work</strong> (<em>callable</em>) &#8211; a single work item</li>
<li><strong>shared_ctx</strong> (<em>object</em>) &#8211; make sure it is picklable. Will be shared
across all threads on a given service.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict mapping (hostname/ip, port) -&gt; worker_id</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ServiceGroup.start_remote_logging">
<code class="descname">start_remote_logging</code><span class="sig-paren">(</span><em>ip</em>, <em>port</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ServiceGroup.start_remote_logging"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ServiceGroup.start_remote_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Start logging on all remote services.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ip</strong> (<em>str</em>) &#8211; hostname or ip of local machine, where a log server is
running</li>
<li><strong>port</strong> (<em>int</em>) &#8211; port number of local log server</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="combtest.worker.ThreadPool">
<em class="property">class </em><code class="descclassname">combtest.worker.</code><code class="descname">ThreadPool</code><span class="sig-paren">(</span><em>max_thread_count=None</em>, <em>work=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A set of threads doing work from a queue asynchronously to the caller. The
caller can add additional work after the work has started. Child classes
can add callbacks for e.g. when work starts/finishes, how to handle errors,
etc.</p>
<dl class="method">
<dt id="combtest.worker.ThreadPool.add_work">
<code class="descname">add_work</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.add_work"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.add_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a work item to this pool. Will not kick threads into action if all
prior work has finished. See <a class="reference internal" href="#combtest.worker.ThreadPool.kick_workers" title="combtest.worker.ThreadPool.kick_workers"><code class="xref py py-func docutils literal"><span class="pre">kick_workers()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.join">
<code class="descname">join</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for all threads to finish, then call on_finish.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.kick_workers">
<code class="descname">kick_workers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.kick_workers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.kick_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>If some workers are dead, reap them and start up new ones to replace
them. This is useful e.g. when adding work after the pool is already
running, since some may have finished and exited.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.on_error_item">
<code class="descname">on_error_item</code><span class="sig-paren">(</span><em>work_item</em>, <em>ctx</em>, <em>exc</em>, <em>tb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.on_error_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.on_error_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if a work item errors out (via Exception).</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.on_finish">
<code class="descname">on_finish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.on_finish"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.on_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when threads are finished up, as indicated by a call to
<a class="reference internal" href="#combtest.worker.ThreadPool.join" title="combtest.worker.ThreadPool.join"><code class="xref py py-func docutils literal"><span class="pre">join()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.on_finish_item">
<code class="descname">on_finish_item</code><span class="sig-paren">(</span><em>work_item</em>, <em>ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.on_finish_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.on_finish_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a work item is finished running.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.on_start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when threads start up to do work for the first time. Not re-run
when they are &#8220;kicked&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.on_start_item">
<code class="descname">on_start_item</code><span class="sig-paren">(</span><em>work_item</em>, <em>ctx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.on_start_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.on_start_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a work item is dequeued and before it is run.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>ctx=None</em>, <em>all_on_next=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run all queued work all the way through to completion, then join.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctx</strong> (<em>object</em>) &#8211; an optional single arg to pass to the work callbacks</li>
<li><strong>all_on_next</strong> (<em>bool</em>) &#8211; rather than each thread popping an item that
it runs (and therefore no other thread runs),
pop a single item and have all threads run it.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.signal_stop">
<code class="descname">signal_stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.signal_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.signal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal threads they should stop when they are done with their current
unit of work. This means they will not stop as quickly as e.g. killing
this proc with a signal. Gives them a chance to finish cleanly.</p>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell threads to start working on any work already queued.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ctx</strong> (<em>object</em>) &#8211; an optional single arg to pass to the work callbacks</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="combtest.worker.ThreadPool.start_all_on_next">
<code class="descname">start_all_on_next</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#ThreadPool.start_all_on_next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.ThreadPool.start_all_on_next" title="Permalink to this definition">¶</a></dt>
<dd><p>This gets all threads running the next work item. This means the item
will potentially be run more than once, and potentially multiple times
in parallel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ctx</strong> (<em>object</em>) &#8211; an optional single arg to pass to the work callbacks</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="combtest.worker.start_remote_services">
<code class="descclassname">combtest.worker.</code><code class="descname">start_remote_services</code><span class="sig-paren">(</span><em>service_class</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#start_remote_services"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.start_remote_services" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplest method to start some services remotely.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>service_class</strong> (<em>class</em>) &#8211; a decendent of <a class="reference internal" href="#combtest.worker.CoordinatorService" title="combtest.worker.CoordinatorService"><code class="xref py py-class docutils literal"><span class="pre">CoordinatorService</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> &#8211; on various issues with service start up</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A ServiceGroup wrapping the started services</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.worker.start_service">
<code class="descclassname">combtest.worker.</code><code class="descname">start_service</code><span class="sig-paren">(</span><em>service_class</em>, <em>port=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#start_service"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.start_service" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an rpyc service given by the provided class. Port can be overridden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>service_class</strong> (<em>rpyc.Service</em>) &#8211; a child class of <code class="xref py py-class docutils literal"><span class="pre">rpyc.Service</span></code>.</li>
<li><strong>port</strong> (<em>int</em>) &#8211; the port the service should listen for requests on. If it
isn&#8217;t provided by the caller, we we get a value from
<a class="reference internal" href="#module-combtest.config" title="combtest.config"><code class="xref py py-class docutils literal"><span class="pre">combtest.config</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a handle to the resulting <code class="xref py py-class docutils literal"><span class="pre">ThreadedServer</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combtest.worker.start_service_by_name">
<code class="descclassname">combtest.worker.</code><code class="descname">start_service_by_name</code><span class="sig-paren">(</span><em>service_name</em>, <em>port=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/combtest/worker.html#start_service_by_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#combtest.worker.start_service_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an rpyc service given by the provided class qualname.
Port can be overridden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>service_name</strong> (<em>str</em>) &#8211; a qualname of achild class of
<code class="xref py py-class docutils literal"><span class="pre">rpyc.Service</span></code>.</li>
<li><strong>port</strong> (<em>int</em>) &#8211; the port the service should listen for requests on. If it
isn&#8217;t provided by the caller, we we get a value from
<a class="reference internal" href="#module-combtest.config" title="combtest.config"><code class="xref py py-class docutils literal"><span class="pre">combtest.config</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a handle to the resulting <code class="xref py py-class docutils literal"><span class="pre">ThreadedServer</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">py-combtest API reference</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-combtest.action">action module</a></li>
<li><a class="reference internal" href="#module-combtest.bootstrap">bootstrap module</a></li>
<li><a class="reference internal" href="#module-combtest.config">config module</a></li>
<li><a class="reference internal" href="#module-combtest.encode">encode module</a></li>
<li><a class="reference internal" href="#module-combtest.forkjoin">forkjoin module</a></li>
<li><a class="reference internal" href="#module-combtest.replay">replay module</a></li>
<li><a class="reference internal" href="#module-combtest.runner">runner module</a></li>
<li><a class="reference internal" href="#module-combtest.ssh_handle">ssh_handle module</a></li>
<li><a class="reference internal" href="#module-combtest.utils">utils module</a></li>
<li><a class="reference internal" href="#module-combtest.walk">walk module</a></li>
<li><a class="reference internal" href="#module-combtest.worker">worker module</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="introduction_combtesting.html" title="previous chapter">An Introduction To Combinatoric Test Case Generation (Combtesting)</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Matthew J. Bryan (Dell/EMC Isilon).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/api.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>